# 知识库按需加载说明

## 设计原则

知识库采用**按需加载**设计，避免一次性加载所有知识占用上下文。

## 问题背景

如果一次性将所有知识库内容加载到系统提示词中：
- ❌ 占用大量上下文token
- ❌ 增加LLM处理负担
- ❌ 降低响应速度
- ❌ 可能超出token限制

## 解决方案

### 1. 提供知识库检索工具

Agent可以通过 `search_knowledge` 工具主动检索相关知识：

```python
search_knowledge(
    query="SQL注入",
    vulnerability_type="SQL注入",  # 可选
    top_k=3  # 返回前3个最相关结果
)
```

### 2. 移除自动加载逻辑

- ❌ **移除前**：系统提示词构建时自动检索知识库
- ✅ **移除后**：Agent按需调用工具检索

### 3. 使用场景

Agent在以下情况可以调用 `search_knowledge`：

1. **遇到不熟悉的漏洞类型**
   ```
   场景：遇到SSTI（服务器端模板注入）
   操作：search_knowledge(query="SSTI模板注入")
   ```

2. **需要参考攻击场景**
   ```
   场景：需要SQL注入的payload示例
   操作：search_knowledge(query="SQL注入 payload")
   ```

3. **需要了解特定漏洞的利用方法**
   ```
   场景：需要XSS绕过过滤的方法
   操作：search_knowledge(query="XSS绕过过滤")
   ```

## 实现对比

### 之前实现（自动加载）

```python
# attacker.py - build_attacker_system_prompt
knowledge_context = state.get("knowledge_context")
if not knowledge_context:
    # 自动检索知识库
    kb = get_knowledge_base()
    results = kb.search(query, top_k=3)
    knowledge_context = kb.format_search_results(query, results)

# 自动加入系统提示词
base_prompt += f"""
{knowledge_context}
"""
```

**问题**：
- 每次构建提示词都会检索
- 即使不需要也会加载
- 占用上下文token

### 现在实现（按需加载）

```python
# 提供工具
@tool
def search_knowledge(query: str, ...) -> str:
    """按需检索知识库"""
    kb = get_knowledge_base()
    results = kb.search(query, top_k=3)
    return kb.format_search_results(query, results)

# Agent主动调用
# Agent: "遇到SQL注入，需要参考相关知识"
# → 调用 search_knowledge(query="SQL注入")
```

**优势**：
- ✅ 只在需要时检索
- ✅ 不占用系统提示词空间
- ✅ Agent自主决定何时需要
- ✅ 更灵活的检索策略

## 工具使用示例

### 示例1：遇到SQL注入

```
Agent思考：
"目标可能存在SQL注入，我需要了解SQL注入的常见payload和利用方法"

Agent调用：
search_knowledge(query="SQL注入", vulnerability_type="SQL注入", top_k=3)

返回：
## 📚 相关知识检索（查询: SQL注入）

### 1. SQL注入-攻击库 (相似度: 0.85)
[SQL注入相关知识内容...]
```

### 示例2：需要XSS绕过方法

```
Agent思考：
"XSS payload被过滤，需要了解绕过方法"

Agent调用：
search_knowledge(query="XSS绕过过滤", top_k=2)

返回：
## 📚 相关知识检索（查询: XSS绕过过滤）

### 1. XSS-攻击库 (相似度: 0.82)
[XSS绕过方法...]
```

## 配置

知识库检索工具的限制：

- **top_k默认值**: 3（最多返回3个结果）
- **最大输出长度**: 2000字符（避免占用过多上下文）
- **单条内容截断**: 500字符（超过则截断）

## 最佳实践

1. **明确查询意图**：使用具体的查询词，如"SQL注入"而不是"注入"
2. **按需调用**：只在真正需要时调用，不要预加载
3. **结合漏洞类型**：如果知道漏洞类型，使用 `vulnerability_type` 参数过滤
4. **限制结果数量**：使用 `top_k` 参数控制返回结果数量

## 与记忆存储的区别

| 特性 | 知识库 | 记忆存储 |
|------|--------|----------|
| 数据来源 | 静态Markdown文档 | Agent运行时发现 |
| 加载方式 | 按需检索 | 自动/手动存储 |
| 使用场景 | 参考攻击场景 | 记录当前发现 |
| 更新频率 | 手动添加文档 | 实时存储 |

## 资料来源

- `knowledge/` 根目录：内置 SQLi / XSS / SSTI 等基础示例
- `knowledge/hpentest/`：从 `agentproject/H-Pentest-main/knowledge/know` 迁移的完整攻击库
- `knowledge/hpentest/knowledge_metadata.json`：提供 `vuln_type`、`tags`、`difficulty`、`summary` 等结构化信息

构建索引时会自动解析这些元数据，使 `search_knowledge` 能根据标签、难度等字段提供更精准的检索结果。

## 总结

知识库按需加载设计：
- ✅ 避免占用上下文
- ✅ 提高响应速度
- ✅ 降低token消耗
- ✅ 更灵活的检索策略

Agent可以根据实际情况主动检索相关知识，而不是被动接受所有内容。

