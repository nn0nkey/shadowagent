"""
æ¸—é€æµ‹è¯•ä¸Šä¸‹æ–‡ç®¡ç†å™¨
ä¸“é—¨ä¸ºæ¸—é€æµ‹è¯•åœºæ™¯è®¾è®¡çš„ä¸Šä¸‹æ–‡å‹ç¼©å’Œç®¡ç†

å…³é”®ä¿¡æ¯åˆ†ç±»ï¼š
1. èµ„äº§çŠ¶æ€ (Target State) - ç›®æ ‡æŒ‡çº¹ã€æŠ€æœ¯æ ˆã€ç½‘ç»œæ‹“æ‰‘
2. æ”»å‡»çº¿ç´¢ (Attack Vectors) - é«˜é£é™©å…¥å£ã€å·²éªŒè¯æ¼æ´ã€æ•æ„Ÿè·¯å¾„
3. å‡­è¯ä¸æƒé™ (Credentials & Access) - æœ€é«˜ä¼˜å…ˆçº§ï¼Œæ°¸ä¸ä¸¢å¼ƒ
4. æ‰§è¡Œå†å² (Execution History) - é¿å…é‡å¤å°è¯•
5. ä¼šè¯çŠ¶æ€ (Session State) - å½“å‰ç«‹è¶³ç‚¹
6. æ—¶é—´æ•æ„Ÿä¿¡æ¯ (Time-Sensitive) - Token è¿‡æœŸç­‰
7. ç¯å¢ƒçº¦æŸ (Constraints) - WAFã€é»‘åå•
8. ä¾èµ–å…³ç³» (Dependencies) - æ”»å‡»é“¾å‰ç½®æ¡ä»¶
"""
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass, field
from datetime import datetime
import re
import json


@dataclass
class TargetState:
    """èµ„äº§çŠ¶æ€ - ç›®æ ‡æŒ‡çº¹"""
    ports: Dict[int, Dict[str, str]] = field(default_factory=dict)  # {80: {"service": "http", "version": "nginx/1.18"}}
    os: Optional[str] = None  # "Linux Ubuntu 20.04"
    tech_stack: Set[str] = field(default_factory=set)  # {"PHP", "MySQL", "Apache"}
    waf_detected: bool = False
    waf_type: Optional[str] = None
    cdn_detected: bool = False
    internal_networks: List[str] = field(default_factory=list)  # å†…ç½‘ç½‘æ®µ


@dataclass
class AttackVector:
    """å•ä¸ªæ”»å‡»å‘é‡"""
    url: str
    method: str = "GET"
    params: List[str] = field(default_factory=list)
    vuln_type: Optional[str] = None  # "SQLi", "XSS", "SSRF"
    verified: bool = False
    payload: Optional[str] = None  # éªŒè¯æˆåŠŸçš„ Payload
    notes: Optional[str] = None


@dataclass
class Credential:
    """å‡­è¯ä¿¡æ¯"""
    cred_type: str  # "password", "hash", "token", "cookie", "api_key"
    username: Optional[str] = None
    value: str = ""
    target: Optional[str] = None  # é€‚ç”¨çš„ç›®æ ‡
    privilege_level: Optional[str] = None  # "admin", "user", "root"
    expires_at: Optional[datetime] = None


@dataclass
class ExecutionRecord:
    """æ‰§è¡Œè®°å½•"""
    action: str  # "ssh_bruteforce", "sqli_test", "dir_scan"
    target: str
    result: str  # "success", "failed", "blocked"
    reason: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class SessionState:
    """ä¼šè¯çŠ¶æ€ - å½“å‰ç«‹è¶³ç‚¹"""
    shell_type: Optional[str] = None  # "reverse_shell", "webshell", "ssh"
    shell_user: Optional[str] = None  # "www-data", "root"
    shell_path: Optional[str] = None  # webshell è·¯å¾„
    can_write: bool = False
    can_outbound: bool = False  # æ˜¯å¦èƒ½å‡ºç½‘
    persistence: List[str] = field(default_factory=list)  # æŒä¹…åŒ–åé—¨
    tunnels: List[str] = field(default_factory=list)  # éš§é“/ä»£ç†


@dataclass 
class PentestContext:
    """æ¸—é€æµ‹è¯•å®Œæ•´ä¸Šä¸‹æ–‡"""
    # 1. èµ„äº§çŠ¶æ€
    target: TargetState = field(default_factory=TargetState)
    
    # 2. æ”»å‡»çº¿ç´¢
    attack_vectors: List[AttackVector] = field(default_factory=list)
    sensitive_paths: List[str] = field(default_factory=list)  # /admin, /backup, .git
    
    # 3. å‡­è¯ä¸æƒé™ (æœ€é«˜ä¼˜å…ˆçº§)
    credentials: List[Credential] = field(default_factory=list)
    current_privilege: str = "anonymous"  # anonymous, user, admin, root
    
    # 4. æ‰§è¡Œå†å²
    history: List[ExecutionRecord] = field(default_factory=list)
    failed_attempts: Dict[str, int] = field(default_factory=dict)  # {"ssh_bruteforce": 2}
    
    # 5. ä¼šè¯çŠ¶æ€
    session: SessionState = field(default_factory=SessionState)
    
    # 6. æ—¶é—´æ•æ„Ÿ
    rate_limited_until: Optional[datetime] = None
    
    # 7. ç¯å¢ƒçº¦æŸ
    blocked_payloads: List[str] = field(default_factory=list)
    effective_bypasses: List[str] = field(default_factory=list)
    
    # 8. å½“å‰ä»»åŠ¡
    current_task: Optional[str] = None
    task_progress: Optional[str] = None


class PentestContextManager:
    """æ¸—é€æµ‹è¯•ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    
    def __init__(self):
        self.context = PentestContext()
    
    def update_from_tool_output(self, tool_name: str, output: str, command: str = ""):
        """ä»å·¥å…·è¾“å‡ºä¸­æå–å¹¶æ›´æ–°ä¸Šä¸‹æ–‡"""
        
        if tool_name == "execute_command":
            self._parse_command_output(command, output)
        elif tool_name == "execute_python_poc":
            self._parse_python_output(output)
    
    def _parse_command_output(self, command: str, output: str):
        """è§£æå‘½ä»¤è¾“å‡º"""
        cmd_lower = command.lower()
        
        # Nmap è¾“å‡ºè§£æ
        if "nmap" in cmd_lower:
            self._parse_nmap(output)
        
        # curl/wget è¾“å‡ºè§£æ
        elif any(x in cmd_lower for x in ["curl", "wget"]):
            self._parse_http_response(output)
        
        # ç›®å½•æ‰«æ
        elif any(x in cmd_lower for x in ["gobuster", "dirb", "dirsearch", "ffuf"]):
            self._parse_dir_scan(output)
        
        # SQLMap
        elif "sqlmap" in cmd_lower:
            self._parse_sqlmap(output)
        
        # é€šç”¨è§£æ
        self._extract_common_info(output)
    
    def _parse_nmap(self, output: str):
        """è§£æ Nmap è¾“å‡º"""
        # ç«¯å£è§£æ: 80/tcp open http nginx 1.18.0
        port_pattern = r'(\d+)/tcp\s+open\s+(\S+)\s*(.*)?'
        for match in re.finditer(port_pattern, output):
            port = int(match.group(1))
            service = match.group(2)
            version = match.group(3).strip() if match.group(3) else ""
            self.context.target.ports[port] = {"service": service, "version": version}
        
        # OS æ£€æµ‹
        os_match = re.search(r'OS details?:\s*(.+)', output)
        if os_match:
            self.context.target.os = os_match.group(1).strip()
    
    def _parse_http_response(self, output: str):
        """è§£æ HTTP å“åº”"""
        # æŠ€æœ¯æ ˆæ£€æµ‹
        tech_patterns = {
            r'X-Powered-By:\s*PHP': 'PHP',
            r'Server:\s*Apache': 'Apache',
            r'Server:\s*nginx': 'Nginx',
            r'X-AspNet-Version': 'ASP.NET',
            r'Set-Cookie:.*JSESSIONID': 'Java',
            r'Set-Cookie:.*laravel_session': 'Laravel',
            r'wp-content|wordpress': 'WordPress',
        }
        for pattern, tech in tech_patterns.items():
            if re.search(pattern, output, re.IGNORECASE):
                self.context.target.tech_stack.add(tech)
        
        # é“¾æ¥æå–ï¼ˆæ›´å…¨é¢ï¼‰
        links = re.findall(r'href=["\']([^"\']+)["\']', output)
        links += re.findall(r'action=["\']([^"\']+)["\']', output)
        links += re.findall(r'src=["\']([^"\']+\.(?:php|jsp|asp|py))["\']', output)
        
        for link in links:
            # æ•æ„Ÿè·¯å¾„å…³é”®è¯
            sensitive_keywords = [
                'admin', 'login', 'signin', 'auth', 'user', 'account',
                'upload', 'api', 'backup', 'config', 'dashboard', 'panel',
                'manage', 'console', 'portal', 'member', 'register'
            ]
            if any(x in link.lower() for x in sensitive_keywords):
                if link not in self.context.sensitive_paths:
                    self.context.sensitive_paths.append(link)
        
        # è¡¨å•æ£€æµ‹ï¼ˆç™»å½•è¡¨å•ç‰¹åˆ«é‡è¦ï¼‰
        form_actions = re.findall(r'<form[^>]*action=["\']([^"\']*)["\'][^>]*>', output, re.IGNORECASE)
        for action in form_actions:
            if action and action not in self.context.sensitive_paths:
                self.context.sensitive_paths.append(action)
        
        # ç™»å½•è¡¨å•ç‰¹å¾æ£€æµ‹
        login_indicators = [
            r'<input[^>]*name=["\'](?:user|username|login|email)["\']',
            r'<input[^>]*name=["\'](?:pass|password|pwd)["\']',
            r'<input[^>]*type=["\']password["\']',
            r'(?:login|signin|ç™»å½•|sign in)',
        ]
        for pattern in login_indicators:
            if re.search(pattern, output, re.IGNORECASE):
                # æ ‡è®°å‘ç°ç™»å½•è¡¨å•
                if "login_form_detected" not in [v.url for v in self.context.attack_vectors]:
                    self.context.attack_vectors.append(AttackVector(
                        url="login_form_detected",
                        vuln_type="auth",
                        notes="å‘ç°ç™»å½•è¡¨å•ï¼Œéœ€è¦æµ‹è¯•è®¤è¯ç»•è¿‡"
                    ))
                break
        
        # WAF æ£€æµ‹
        waf_signatures = ['403 Forbidden', 'Access Denied', 'WAF', 'Firewall', 'blocked']
        if any(sig in output for sig in waf_signatures):
            self.context.target.waf_detected = True
    
    def _parse_dir_scan(self, output: str):
        """è§£æç›®å½•æ‰«æç»“æœ"""
        # æå–å‘ç°çš„è·¯å¾„
        path_pattern = r'(/[\w\-\./]+)\s+.*(?:200|301|302|403)'
        for match in re.finditer(path_pattern, output):
            path = match.group(1)
            if path not in self.context.sensitive_paths:
                self.context.sensitive_paths.append(path)
    
    def _parse_sqlmap(self, output: str):
        """è§£æ SQLMap è¾“å‡º"""
        # æ£€æµ‹åˆ°æ³¨å…¥
        if "is vulnerable" in output.lower() or "injectable" in output.lower():
            # æå–å‚æ•°
            param_match = re.search(r"Parameter:\s*(\S+)", output)
            if param_match:
                vector = AttackVector(
                    url="",  # éœ€è¦ä»å‘½ä»¤ä¸­æå–
                    params=[param_match.group(1)],
                    vuln_type="SQLi",
                    verified=True
                )
                self.context.attack_vectors.append(vector)
        
        # æå–æ•°æ®åº“ç±»å‹
        db_match = re.search(r"back-end DBMS:\s*(\S+)", output)
        if db_match:
            self.context.target.tech_stack.add(db_match.group(1))
    
    def _extract_common_info(self, output: str):
        """æå–é€šç”¨ä¿¡æ¯"""
        # FLAG æ£€æµ‹
        flags = re.findall(r'flag\{[^}]+\}', output, re.IGNORECASE)
        for flag in flags:
            cred = Credential(cred_type="flag", value=flag)
            if cred not in self.context.credentials:
                self.context.credentials.append(cred)
        
        # å¯†ç /å‡­è¯æ£€æµ‹
        cred_patterns = [
            (r'password["\s:=]+([^\s"\'<>]+)', 'password'),
            (r'passwd["\s:=]+([^\s"\'<>]+)', 'password'),
            (r'token["\s:=]+([A-Za-z0-9\-_\.]+)', 'token'),
            (r'api[_-]?key["\s:=]+([A-Za-z0-9\-_]+)', 'api_key'),
        ]
        for pattern, cred_type in cred_patterns:
            for match in re.finditer(pattern, output, re.IGNORECASE):
                value = match.group(1)
                if len(value) > 3:  # è¿‡æ»¤å¤ªçŸ­çš„
                    cred = Credential(cred_type=cred_type, value=value)
                    self.context.credentials.append(cred)
    
    def _parse_python_output(self, output: str):
        """è§£æ Python è„šæœ¬è¾“å‡º"""
        self._extract_common_info(output)
    
    def add_execution_record(self, action: str, target: str, result: str, reason: str = None):
        """æ·»åŠ æ‰§è¡Œè®°å½•"""
        record = ExecutionRecord(
            action=action,
            target=target,
            result=result,
            reason=reason
        )
        self.context.history.append(record)
        
        # æ›´æ–°å¤±è´¥è®¡æ•°
        if result == "failed":
            key = f"{action}:{target}"
            self.context.failed_attempts[key] = self.context.failed_attempts.get(key, 0) + 1
    
    def add_credential(self, cred_type: str, value: str, username: str = None, 
                       target: str = None, privilege: str = None):
        """æ·»åŠ å‡­è¯"""
        cred = Credential(
            cred_type=cred_type,
            username=username,
            value=value,
            target=target,
            privilege_level=privilege
        )
        self.context.credentials.append(cred)
    
    def add_attack_vector(self, url: str, method: str = "GET", params: List[str] = None,
                          vuln_type: str = None, verified: bool = False, payload: str = None):
        """æ·»åŠ æ”»å‡»å‘é‡"""
        vector = AttackVector(
            url=url,
            method=method,
            params=params or [],
            vuln_type=vuln_type,
            verified=verified,
            payload=payload
        )
        self.context.attack_vectors.append(vector)
    
    def should_skip_action(self, action: str, target: str, max_attempts: int = 3) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥è·³è¿‡æŸä¸ªæ“ä½œï¼ˆå·²ç»å¤±è´¥å¤ªå¤šæ¬¡ï¼‰"""
        key = f"{action}:{target}"
        return self.context.failed_attempts.get(key, 0) >= max_attempts
    
    def check_target_alignment(self, challenge_description: str) -> dict:
        """
        æ£€æŸ¥ä¸»æ”»æ‰‹çš„æ“ä½œæ˜¯å¦ä¸é¢˜ç›®ç›®æ ‡ä¸€è‡´
        
        Returns:
            {
                "aligned": bool,
                "issues": [str],
                "suggestions": [str]
            }
        """
        result = {"aligned": True, "issues": [], "suggestions": []}
        desc_lower = challenge_description.lower()
        
        # æ£€æŸ¥1: é¢˜ç›®è¯´"ç™»å½•"ä½†æ²¡æœ‰æ‰¾åˆ°/è®¿é—®ç™»å½•é¡µé¢
        if any(kw in desc_lower for kw in ['ç™»å½•', 'login', 'admin', 'ç®¡ç†å‘˜']):
            login_found = any('login' in v.url.lower() or 'admin' in v.url.lower() 
                            for v in self.context.attack_vectors if v.url)
            login_path_found = any('login' in p.lower() or 'admin' in p.lower() 
                                  for p in self.context.sensitive_paths)
            
            if not login_found and not login_path_found:
                result["aligned"] = False
                result["issues"].append("é¢˜ç›®è¦æ±‚ç™»å½•ï¼Œä½†å°šæœªå‘ç°æˆ–è®¿é—®ç™»å½•é¡µé¢")
                result["suggestions"].append("å…ˆæ‰«æ /admin, /login, /admin.php, /login.php ç­‰è·¯å¾„")
        
        # æ£€æŸ¥2: é¢˜ç›®è¯´"IDOR"ä½†åœ¨åšè®¤è¯ç›¸å…³æ“ä½œ
        if 'idor' in desc_lower or 'unauthorized' in desc_lower:
            # IDOR é€šå¸¸ä¸éœ€è¦ç™»å½•
            result["suggestions"].append("IDOR æ¼æ´é€šå¸¸ä¸éœ€è¦ç™»å½•ï¼Œç›´æ¥æšä¸¾ ID å‚æ•°")
        
        # æ£€æŸ¥3: é‡å¤å¤±è´¥æ£€æµ‹
        failed_actions = {k: v for k, v in self.context.failed_attempts.items() if v >= 3}
        if failed_actions:
            result["aligned"] = False
            for action, count in failed_actions.items():
                result["issues"].append(f"'{action}' å·²å¤±è´¥ {count} æ¬¡ï¼Œåº”è¯¥æ¢æ–¹å‘")
        
        return result
    
    def to_prompt_context(self) -> str:
        """ç”Ÿæˆç”¨äº Prompt çš„å‹ç¼©ä¸Šä¸‹æ–‡"""
        sections = []
        
        # 1. èµ„äº§çŠ¶æ€
        target = self.context.target
        if target.ports or target.tech_stack:
            asset_info = []
            if target.ports:
                ports_str = ", ".join(f"{p}:{v['service']}" for p, v in target.ports.items())
                asset_info.append(f"ç«¯å£: {ports_str}")
            if target.os:
                asset_info.append(f"OS: {target.os}")
            if target.tech_stack:
                asset_info.append(f"æŠ€æœ¯æ ˆ: {', '.join(target.tech_stack)}")
            if target.waf_detected:
                asset_info.append(f"âš ï¸ WAF: {target.waf_type or 'å·²æ£€æµ‹'}")
            sections.append("ã€èµ„äº§çŠ¶æ€ã€‘\n" + "\n".join(asset_info))
        
        # 2. æ”»å‡»çº¿ç´¢
        if self.context.attack_vectors or self.context.sensitive_paths:
            attack_info = []
            for v in self.context.attack_vectors[:5]:  # æœ€å¤š5ä¸ª
                status = "âœ…å·²éªŒè¯" if v.verified else "â“å¾…æµ‹è¯•"
                attack_info.append(f"- {v.url} [{v.vuln_type}] {status}")
            if self.context.sensitive_paths:
                attack_info.append(f"æ•æ„Ÿè·¯å¾„: {', '.join(self.context.sensitive_paths[:10])}")
            sections.append("ã€æ”»å‡»çº¿ç´¢ã€‘\n" + "\n".join(attack_info))
        
        # 3. å‡­è¯ä¸æƒé™ (æœ€é«˜ä¼˜å…ˆçº§ï¼Œå®Œæ•´ä¿ç•™)
        if self.context.credentials:
            cred_info = []
            for c in self.context.credentials:
                if c.cred_type == "flag":
                    cred_info.append(f"ğŸš© FLAG: {c.value}")
                else:
                    cred_info.append(f"- [{c.cred_type}] {c.username or ''}: {c.value[:20]}...")
            sections.append("ã€å‡­è¯ä¿¡æ¯ã€‘âš ï¸é‡è¦\n" + "\n".join(cred_info))
        
        # 4. æ‰§è¡Œå†å² (åªä¿ç•™æ‘˜è¦)
        if self.context.history:
            recent = self.context.history[-5:]  # æœ€è¿‘5æ¡
            history_info = []
            for h in recent:
                emoji = "âœ…" if h.result == "success" else "âŒ" if h.result == "failed" else "ğŸš«"
                history_info.append(f"{emoji} {h.action} â†’ {h.result}")
            
            # å¤±è´¥ç»Ÿè®¡
            if self.context.failed_attempts:
                failed_str = ", ".join(f"{k}Ã—{v}" for k, v in self.context.failed_attempts.items() if v >= 2)
                if failed_str:
                    history_info.append(f"âš ï¸ å¤šæ¬¡å¤±è´¥: {failed_str}")
            
            sections.append("ã€æ‰§è¡Œå†å²ã€‘\n" + "\n".join(history_info))
        
        # 5. ä¼šè¯çŠ¶æ€
        session = self.context.session
        if session.shell_type:
            session_info = f"Shell: {session.shell_type} ({session.shell_user})"
            if session.can_write:
                session_info += " [å¯å†™]"
            if session.can_outbound:
                session_info += " [å¯å‡ºç½‘]"
            sections.append(f"ã€å½“å‰ä¼šè¯ã€‘{session_info}")
        
        # 6. å½“å‰ä»»åŠ¡
        if self.context.current_task:
            sections.append(f"ã€å½“å‰ä»»åŠ¡ã€‘{self.context.current_task}")
        
        return "\n\n".join(sections)
    
    def to_json(self) -> str:
        """å¯¼å‡ºä¸º JSONï¼ˆç”¨äºæŒä¹…åŒ–ï¼‰"""
        def serialize(obj):
            if isinstance(obj, datetime):
                return obj.isoformat()
            elif isinstance(obj, set):
                return list(obj)
            elif hasattr(obj, '__dict__'):
                return {k: serialize(v) for k, v in obj.__dict__.items()}
            elif isinstance(obj, list):
                return [serialize(i) for i in obj]
            elif isinstance(obj, dict):
                return {k: serialize(v) for k, v in obj.items()}
            return obj
        
        return json.dumps(serialize(self.context), ensure_ascii=False, indent=2)
    
    def reset(self):
        """é‡ç½®ä¸Šä¸‹æ–‡"""
        self.context = PentestContext()


# å…¨å±€å®ä¾‹
_context_manager: Optional[PentestContextManager] = None


def get_pentest_context() -> PentestContextManager:
    """è·å–å…¨å±€æ¸—é€æµ‹è¯•ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    global _context_manager
    if _context_manager is None:
        _context_manager = PentestContextManager()
    return _context_manager


def reset_pentest_context():
    """é‡ç½®å…¨å±€ä¸Šä¸‹æ–‡"""
    global _context_manager
    _context_manager = PentestContextManager()
